(function(){(this||window).webpackJsonp.registerAbsMids({"esri/views/webgl/Texture":1560,"esri/views/webgl/FramebufferObject":1562,"esri/views/webgl/Renderbuffer":1612,"esri/views/2d/engine/DisplayObject":1616,"esri/views/layers/LayerView":1621,"esri/views/2d/engine/Evented":1641,"esri/views/2d/engine/webgl/shaders/sources/resolver":1809,"esri/views/vectorTiles/renderers/rendererUtils":1891,"esri/views/2d/engine/webgl/BitBlitRenderer":1946,"esri/views/vectorTiles/MemoryBuffer":1949,"esri/views/2d/engine/webgl/shaders/sources/shaderRepository":1960,"esri/views/2d/engine/webgl/shaders/BitBlitPrograms":1962,"esri/views/vectorTiles/Rect":2015,"esri/views/vectorTiles/TileHandler":2078,"esri/views/vectorTiles/RectangleBinPack":2079,"esri/views/vectorTiles/VectorTileDisplayObject":2080,"esri/views/vectorTiles/renderers/Renderer":2081,"esri/views/vectorTiles/GlyphMosaic":2458,"esri/views/vectorTiles/GlyphSource":2459,"esri/views/vectorTiles/SpriteMosaic":2460,"esri/views/vectorTiles/SpriteSource":2461,"esri/views/vectorTiles/TileIndex":2462,"esri/views/vectorTiles/RenderBucket":2463,"esri/views/vectorTiles/renderers/FadeRecorder":2465,"esri/views/vectorTiles/renderers/BackgroundRenderer":2466,"esri/views/vectorTiles/renderers/CircleRenderer":2467,"esri/views/vectorTiles/renderers/FillRenderer":2468,"esri/views/vectorTiles/renderers/LineRenderer":2469,"esri/views/vectorTiles/renderers/SymbolRenderer":2470,"esri/views/vectorTiles/renderers/IconRenderer":2471,"esri/views/vectorTiles/renderers/SDFRenderer":2472,"esri/views/vectorTiles/renderers/TileInfoRenderer":2473,"esri/views/vectorTiles/renderers/shaders/ProgramCache":2474,"esri/views/vectorTiles/renderers/shaders/Programs":2475,"esri/views/vectorTiles/renderers/shaders/sources/resolver":2476,"esri/views/vectorTiles/renderers/shaders/sources/shaderRepository":2477})})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{1560:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19)],void 0===(r=function(e,t,i){return function(){function e(t,n,r){this._context=null,this._glName=null,this._id=-1,this._desc=void 0,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._boundToUnits=new Set,this._context=t,this._desc={pixelFormat:n.pixelFormat,internalFormat:n.internalFormat,dataType:n.dataType,target:n.target?n.target:3553,samplingMode:n.samplingMode?n.samplingMode:9729,wrapMode:n.wrapMode?n.wrapMode:10497,maxAnisotropy:n.maxAnisotropy,flipped:void 0!==n.flipped&&n.flipped,hasMipmap:void 0!==n.hasMipmap&&n.hasMipmap,unpackAlignment:n.unpackAlignment?n.unpackAlignment:4,width:n.width,height:n.height,preMultiplyAlpha:void 0!==n.preMultiplyAlpha&&n.preMultiplyAlpha},this._id=++e._nextId,i("esri-webgl-debug")&&t.instanceCounter.incrementCount(0),this.setData(r)}return Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"glName",{get:function(){return this._glName},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._desc},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){var e=this;if(this._context){if(this._glName){var t=this._context.gl;this._boundToUnits.forEach(function(t){e._context.bindTexture(null,t)}),t.deleteTexture(this._glName),this._glName=null}i("esri-webgl-debug")&&this._context.instanceCounter.decrementCount(0),this._context=null}},e.prototype.resize=function(e,t){var i=this._desc;i.width===e&&i.height===t||(i.width=e,i.height=t,this.setData(null))},e.prototype.setData=function(t){var i=this._context.gl;this._glName||(this._glName=i.createTexture()),void 0===t&&(t=null),null===t&&(this._desc.width=this._desc.width||4,this._desc.height=this._desc.height||4);var n=this._context.getBoundTexture(0);this._context.bindTexture(this,0);var r=this._desc;e._validateTexture(r),i.pixelStorei(i.UNPACK_ALIGNMENT,r.unpackAlignment),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,r.flipped?1:0),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,r.preMultiplyAlpha?1:0);var a=r.pixelFormat,o=r.internalFormat?r.internalFormat:a;if(t instanceof ImageData||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement)r.width&&r.height&&console.assert(t.width===r.width&&t.height===r.height),i.texImage2D(i.TEXTURE_2D,0,o,a,r.dataType,t),r.hasMipmap&&this.generateMipmap(),void 0===this._desc.width&&(this._desc.width=t.width),void 0===this._desc.height&&(this._desc.height=t.height);else{null!=r.width&&null!=r.height||console.error("Width and height must be specified!"),i.DEPTH24_STENCIL8&&o===i.DEPTH_STENCIL&&(o=i.DEPTH24_STENCIL8);var s=r.width,l=r.height;if(function(e){return null!=e&&"type"in e&&"compressed"===e.type}(t))for(var u=0;;++u){var d=t.levels[Math.min(u,t.levels.length-1)];if(i.compressedTexImage2D(i.TEXTURE_2D,u,o,s,l,0,d),1===s&&1===l||!r.hasMipmap)break;s=Math.max(1,s>>1),l=Math.max(1,l>>1)}else if(t)i.texImage2D(i.TEXTURE_2D,0,o,s,l,0,a,r.dataType,t),r.hasMipmap&&this.generateMipmap();else for(u=0;i.texImage2D(i.TEXTURE_2D,u,o,s,l,0,a,r.dataType,null),(1!==s||1!==l)&&r.hasMipmap;++u)s=Math.max(1,s>>1),l=Math.max(1,l>>1)}e._applySamplingMode(i,this._desc),e._applyWrapMode(i,this._desc),e._applyAnisotropicFilteringParameters(this._context,this._desc),this._context.bindTexture(n,0)},e.prototype.updateData=function(e,t,i,n,r,a){a||console.error("An attempt to use uninitialized data!"),this._glName||console.error("An attempt to update uninitialized texture!");var o=this._context.gl,s=this._desc,l=this._context.getBoundTexture(0);this._context.bindTexture(this,0),(t<0||i<0||n>s.width||r>s.height||t+n>s.width||i+r>s.height)&&console.error("An attempt to update out of bounds of the texture!"),a instanceof ImageData||a instanceof HTMLImageElement||a instanceof HTMLCanvasElement||a instanceof HTMLVideoElement?(console.assert(a.width===n&&a.height===r),o.texSubImage2D(o.TEXTURE_2D,e,t,i,s.pixelFormat,s.dataType,a)):o.texSubImage2D(o.TEXTURE_2D,e,t,i,n,r,s.pixelFormat,s.dataType,a),this._context.bindTexture(l,0)},e.prototype.generateMipmap=function(){var t=this._desc;t.hasMipmap||(t.hasMipmap=!0,e._validateTexture(t)),9729===t.samplingMode?(this._samplingModeDirty=!0,t.samplingMode=9985):9728===t.samplingMode&&(this._samplingModeDirty=!0,t.samplingMode=9984);var i=this._context.getBoundTexture(0);this._context.bindTexture(this,0);var n=this._context.gl;n.generateMipmap(n.TEXTURE_2D),this._context.bindTexture(i,0)},e.prototype.setSamplingMode=function(t){t!==this._desc.samplingMode&&(this._desc.samplingMode=t,e._validateTexture(this._desc),this._samplingModeDirty=!0)},e.prototype.setWrapMode=function(t){t!==this._desc.wrapMode&&(this._desc.wrapMode=t,e._validateTexture(this._desc),this._wrapModeDirty=!0)},e.prototype.applyChanges=function(){var t=this._context.gl,i=this._desc;this._samplingModeDirty&&(e._applySamplingMode(t,i),this._samplingModeDirty=!1),this._wrapModeDirty&&(e._applyWrapMode(t,i),this._wrapModeDirty=!1)},e.prototype.setBoundToUnit=function(e,t){t?this._boundToUnits.add(e):this._boundToUnits.delete(e)},e._isPowerOfTwo=function(e){return 0==(e&e-1)},e._validateTexture=function(t){(t.width<0||t.height<0)&&console.error("Negative dimension parameters are not allowed!"),e._isPowerOfTwo(t.width)&&e._isPowerOfTwo(t.height)||("number"==typeof t.wrapMode?33071!==t.wrapMode&&console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"):33071===t.wrapMode.s&&33071===t.wrapMode.t||console.error("Non-power-of-two textures must have a wrap mode of CLAMP_TO_EDGE!"),t.hasMipmap&&console.error("Mipmapping requires power-of-two textures!"))},e._applySamplingMode=function(e,t){var i=t.samplingMode;9985===i||9987===i?i=9729:9984!==i&&9986!==i||(i=9728),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,t.samplingMode)},e._applyWrapMode=function(e,t){"number"==typeof t.wrapMode?(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,t.wrapMode.t))},e._applyAnisotropicFilteringParameters=function(e,t){if(null!=t.maxAnisotropy){var i=e.capabilities.textureFilterAnisotropic;if(i){var n=e.gl;n.texParameterf(n.TEXTURE_2D,i.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy)}}},e._nextId=0,e}()}.apply(null,n))||(e.exports=r)},1562:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19),i(1612),i(1560)],void 0===(r=function(e,t,i,n,r){return function(){function e(t,a,o,s){if(this._context=null,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachment=null,this._initialized=!1,this._context=t,this._desc={colorTarget:a.colorTarget,depthStencilTarget:a.depthStencilTarget,width:a.width,height:a.height,multisampled:a.multisampled},this._id=e._nextId++,i("esri-webgl-debug")&&t.instanceCounter.incrementCount(4),o){var l=void 0;o instanceof r?(this._colorAttachment=o,l=o.descriptor):(l=o,this._colorAttachment=new r(this._context,l)),0!==this._desc.colorTarget&&console.error("Framebuffer is initialized with a texture however the descriptor indicates using a renderbuffer color attachment!"),e._validateTextureDimensions(l,this._desc)}if(s instanceof n)2===a.depthStencilTarget?this._stencilAttachment=s:1===a.depthStencilTarget||3===a.depthStencilTarget?this._depthAttachment=s:console.error('If a Renderbuffer is provided, "depthStencilTarget" must be one of STENCIL_RENDER_BUFFER, DEPTH_RENDER_BUFFER or DEPTH_STENCIL_RENDER_BUFFER'),e._validateBufferDimensions(s.descriptor,this._desc);else if(s){this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");var u=void 0;s instanceof r?(this._depthStencilTexture=s,u=this._depthStencilTexture.descriptor):(u=s,this._depthStencilTexture=new r(this._context,u)),e._validateTextureDimensions(u,this._desc)}}return e.create=function(t,i){return new e(t,i)},e.createWithAttachments=function(t,i,n,r){return new e(t,n,i,r)},Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"glName",{get:function(){return this._glName},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._desc},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"colorTexture",{get:function(){return this._colorAttachment instanceof r?this._colorAttachment:null},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"depthStencilTexture",{get:function(){return this._depthStencilTexture},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"width",{get:function(){return this._desc.width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._desc.height},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){this._context&&(this._disposeColorAttachment(),this._disposeDepthStencilAttachments(),this._glName&&(this._context.gl.deleteFramebuffer(this._glName),this._glName=null),i("esri-webgl-debug")&&this._context.instanceCounter.decrementCount(4),this._context=null)},e.prototype.attachColorTexture=function(t){if(t){var i=t.descriptor;if(e._validateTextureDimensions(i,this._desc),this._disposeColorAttachment(),this._initialized){this._context.bindFramebuffer(this);var n=this._context.gl;n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t.glName,0)}this._colorAttachment=t}},e.prototype.detachColorTexture=function(){var e=void 0;if(this._colorAttachment instanceof r){if(e=this._colorAttachment,this._initialized){this._context.bindFramebuffer(this);var t=this._context.gl;this._context.gl.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)}this._colorAttachment=null}return e},e.prototype.attachDepthStencilTexture=function(t){if(t){var i=t.descriptor;if(34041!==i.pixelFormat&&console.error("Depth/Stencil texture must have a pixel type of DEPTH_STENCIL!"),34042!==i.dataType&&console.error("Depth/Stencil texture must have data type of UNSIGNED_INT_24_8_WEBGL!"),this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture!"),e._validateTextureDimensions(i,this._desc),4!==this._desc.depthStencilTarget&&(this._desc.depthStencilTarget=4),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);var n=this._context.gl;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,t.glName,0)}this._depthStencilTexture=t}},e.prototype.detachDepthStencilTexture=function(){var e=this._depthStencilTexture;if(e&&this._initialized){this._context.bindFramebuffer(this);var t=this._context.gl;this._context.gl.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,null,0)}return this._depthStencilTexture=null,e},e.prototype.attachDepthStencilBuffer=function(t){if(t){var i=t.descriptor;if(34041!==i.internalFormat&&33189!==i.internalFormat&&console.error("Depth/Stencil buffer must have correct internalFormat"),e._validateBufferDimensions(i,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=34041===i.internalFormat?3:1,this._initialized){this._context.bindFramebuffer(this);var n=this._context.gl,r=1===this._desc.depthStencilTarget?n.DEPTH_ATTACHMENT:n.DEPTH_STENCIL_ATTACHMENT;n.framebufferRenderbuffer(n.FRAMEBUFFER,r,n.RENDERBUFFER,t.glName)}this._depthAttachment=t}},e.prototype.detachDepthStencilBuffer=function(){var e=this._context.gl,t=this._depthAttachment;if(t&&this._initialized){this._context.bindFramebuffer(this);var i=1===this._desc.depthStencilTarget?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(e.FRAMEBUFFER,i,e.RENDERBUFFER,null)}return this._depthAttachment=null,t},e.prototype.copyToTexture=function(e,t,i,n,r,a,o){(e<0||t<0||r<0||a<0)&&console.error("Offsets cannot be negative!"),(i<=0||n<=0)&&console.error("Copy width and height must be greater than zero!");var s=this._desc,l=o.descriptor;3553!==o.descriptor.target&&console.error("Texture target must be TEXTURE_2D!"),(e+i>s.width||t+n>s.height||r+i>l.width||a+n>l.height)&&console.error("Bad dimensions, the current input values will attempt to read or copy out of bounds!");var u=this._context;u.bindTexture(o),u.bindFramebuffer(this),u.gl.copyTexSubImage2D(3553,0,r,a,e,t,i,n)},e.prototype.readPixels=function(e,t,i,n,r,a,o){(i<=0||n<=0)&&console.error("Copy width and height must be greater than zero!"),o||console.error("Target memory is not initialized!"),this._context.bindFramebuffer(this),this._context.gl.readPixels(e,t,i,n,r,a,o)},e.prototype.resize=function(t,i){var n=this._desc;if(n.width!==t||n.height!==i){if(!this._initialized){if(n.width=t,n.height=i,this._colorAttachment instanceof r)(a=this._colorAttachment).resize(t,i);return void(this._depthStencilTexture&&this._depthStencilTexture.resize(t,i))}var a,o;if(n.width=t,n.height=i,this._colorAttachment instanceof r)(o=(a=this._colorAttachment).descriptor).width=t,o.height=i,this._colorAttachment.dispose(),this._colorAttachment=new r(this._context,o),e._validateTextureDimensions(a.descriptor,this._desc);else this._colorAttachment&&this._disposeColorAttachment();if(null!=this._depthStencilTexture)(o=this._depthStencilTexture.descriptor).width=t,o.height=i,this._depthStencilTexture.dispose(),this._depthStencilTexture=new r(this._context,o);else(this._depthAttachment||this._stencilAttachment)&&this._disposeDepthStencilAttachments();this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}},e.prototype.initialize=function(){if(this._initialized)return!1;var e=this._context.gl;this._glName&&e.deleteFramebuffer(this._glName);var t=e.createFramebuffer(),i=this._desc;if(e.bindFramebuffer(e.FRAMEBUFFER,t),!this._colorAttachment)if(0===i.colorTarget){var a={target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,wrapMode:33071,width:i.width,height:i.height};this._colorAttachment=new r(this._context,a)}else{var o=new n(this._context,{internalFormat:32854,width:i.width,height:i.height});e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,o.glName),this._colorAttachment=o}if(this._colorAttachment instanceof r){var s=this._colorAttachment;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s.glName,0)}switch(i.depthStencilTarget){case 1:case 3:this._depthAttachment||(this._depthAttachment=new n(this._context,{internalFormat:1===i.depthStencilTarget?33189:34041,width:i.width,height:i.height}));var l=1===i.depthStencilTarget?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(e.FRAMEBUFFER,l,e.RENDERBUFFER,this._depthAttachment.glName);break;case 2:this._stencilAttachment||(this._stencilAttachment=new n(this._context,{internalFormat:36168,width:i.width,height:i.height})),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,this._stencilAttachment.glName);break;case 4:if(!this._depthStencilTexture){this._context.capabilities.depthTexture||console.error("Extension WEBGL_depth_texture isn't supported therefore it is no possible to set the depth/stencil texture as an attachment!");var u={target:3553,pixelFormat:34041,dataType:34042,samplingMode:9728,wrapMode:33071,width:i.width,height:i.height};this._depthStencilTexture=new r(this._context,u)}e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,this._depthStencilTexture.glName,0)}return e.checkFramebufferStatus(e.FRAMEBUFFER)!==e.FRAMEBUFFER_COMPLETE&&console.error("Framebuffer is incomplete!"),this._glName=t,this._initialized=!0,!0},e.prototype._disposeColorAttachment=function(){if(this._colorAttachment instanceof r){var e=this._colorAttachment;if(this._initialized)this._context.bindFramebuffer(this),(i=this._context.gl).framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,null,0);e.dispose()}else if(this._colorAttachment instanceof WebGLRenderbuffer){var t=this._colorAttachment,i=this._context.gl;this._initialized&&(this._context.bindFramebuffer(this),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,null)),this._context.gl.deleteRenderbuffer(t)}this._colorAttachment=null},e.prototype._disposeDepthStencilAttachments=function(){var e=this._context.gl;if(this._depthAttachment){if(this._initialized){this._context.bindFramebuffer(this);var t=1===this._desc.depthStencilTarget?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(e.FRAMEBUFFER,t,e.RENDERBUFFER,null)}this._depthAttachment.dispose(),this._depthAttachment=null}this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,null,0)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)},e._validateBufferDimensions=function(e,t){console.assert(e.width>=0&&e.height>=0),void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===e.width&&t.height===e.height||console.error("Renderbuffer dimensions must match the framebuffer's!"):(t.width=e.width,t.height=e.height)},e._validateTextureDimensions=function(e,t){console.assert(e.width>=0&&e.height>=0),3553!==e.target&&console.error("Texture type must be TEXTURE_2D!"),void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===e.width&&t.height===e.height||console.error("Color attachment texture must match the framebuffer's!"):(t.width=e.width,t.height=e.height)},e._nextId=0,e}()}.apply(null,n))||(e.exports=r)},1612:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19)],void 0===(r=function(e,t,i){return function(){function e(t,n){this._context=t,this._desc=n,this._glName=null,this._id=-1;var r=this._context.gl;i("esri-webgl-debug")&&this._context.instanceCounter.incrementCount(5),this._id=++e._nextId,this._glName=r.createRenderbuffer(),this._context.bindRenderbuffer(this),r.renderbufferStorage(r.RENDERBUFFER,n.internalFormat,n.width,n.height)}return Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._desc},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"glName",{get:function(){return this._glName},enumerable:!0,configurable:!0}),e.prototype.resize=function(e,t){var i=this._context.gl,n=this._desc;n.width===e&&n.height===t||(n.width=e,n.height=t,this._context.bindRenderbuffer(this),i.renderbufferStorage(i.RENDERBUFFER,n.internalFormat,n.width,n.height))},e.prototype.dispose=function(){this._glName&&(this._context.gl.deleteRenderbuffer(this._glName),this._glName=null),i("esri-webgl-debug")&&this._context.instanceCounter.decrementCount(5),this._context=null},e._nextId=0,e}()}.apply(null,n))||(e.exports=r)},1616:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(26),i(1641)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t._renderRequestedCalled=!1,t._attached=!1,t._isReady=!1,t._opacity=1,t.renderRequested=!1,t._visible=!0,t}return i(t,e),Object.defineProperty(t.prototype,"attached",{get:function(){return this._attached},set:function(e){this._attached!==e&&(this._attached=e,e?this.hasEventListener("attach")&&this.emit("attach"):this.hasEventListener("detach")&&this.emit("detach"))},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isReady",{get:function(){return this._attached&&this._isReady},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"opacity",{get:function(){return this._opacity},set:function(e){this._opacity!==e&&(this._opacity=e,this.requestRender())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"visible",{get:function(){return this._visible},set:function(e){this._visible!==e&&(this._visible=e,this.requestRender())},enumerable:!0,configurable:!0}),t.prototype.attach=function(){return this.ready(),!0},t.prototype.detach=function(){},t.prototype.processRender=function(e){this.visible&&this.attached&&(this._renderRequestedCalled=!1,this.doRender(e),this._renderRequestedCalled||(this.renderRequested=!1),this.hasEventListener("post-render")&&this.emit("post-render"))},t.prototype.requestRender=function(){var e=this.renderRequested;this._renderRequestedCalled=!0,this.renderRequested=!0,this.parent&&this.parent.requestChildRender(this),e!==this.renderRequested&&this.hasEventListener("will-render")&&this.emit("will-render")},t.prototype.dispose=function(){},t.prototype.ready=function(){this._isReady=!0,this.hasEventListener("isReady")&&this.emit("isReady")},t}(n.Evented);t.DisplayObject=r}.apply(null,n))||(e.exports=r)},1621:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2),i(0),i(32),i(1602),i(140),i(9),i(181),i(7),i(1)],void 0===(r=function(e,t,i,n,r,a,o,s,l,u,d){return function(e){function t(t){var i=e.call(this)||this;return i.layer=null,i.parent=null,i.view=null,i}return i(t,e),t.prototype.initialize=function(){var e=this;this.addResolvingPromise(this.layer),this.when().catch(function(t){if("layerview:create-error"!==t.name){var i=e.layer&&e.layer.id||"no id",n=e.layer&&e.layer.title||"no title";return s.getLogger(e.declaredClass).error("#resolve()","Failed to resolve layer view (layer title: '"+n+"', id: '"+i+"')",t),u.reject(t)}})},t.prototype.destroy=function(){this.layer=this.view=this.parent=null},Object.defineProperty(t.prototype,"suspended",{get:function(){return!this.canResume()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"updating",{get:function(){return!this.suspended&&this.isUpdating()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"visible",{get:function(){return!0===this.get("layer.visible")},set:function(e){void 0!==e?this._override("visible",e):this._clearOverride("visible")},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"fullOpacity",{get:function(){var e=function(e){return null!=e?e:1};return e(this.get("layer.opacity"))*e(this.get("parent.fullOpacity"))},enumerable:!0,configurable:!0}),t.prototype.canResume=function(){return!this.get("parent.suspended")&&this.get("view.ready")&&this.get("layer.loaded")&&this.visible||!1},t.prototype.isUpdating=function(){return!1},n([d.property()],t.prototype,"layer",void 0),n([d.property()],t.prototype,"parent",void 0),n([d.property({readOnly:!0,dependsOn:["view","visible","layer.loaded","parent.suspended"]})],t.prototype,"suspended",null),n([d.property({type:Boolean,dependsOn:["suspended"],readOnly:!0})],t.prototype,"updating",null),n([d.property()],t.prototype,"view",void 0),n([d.property({dependsOn:["layer.visible"]})],t.prototype,"visible",null),n([d.property({dependsOn:["layer.opacity","parent.fullOpacity"]})],t.prototype,"fullOpacity",null),n([d.subclass("esri.views.layers.LayerView")],t)}(d.declared(a,r,o.Identifiable,l))}.apply(null,n))||(e.exports=r)},1641:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(26),i(86),i(51)],void 0===(r=function(e,t,i,n,r){Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(){}return e.prototype.on=function(e,t){return n.after(this,"on"+e,t,!0)},e.prototype.once=function(e,t){return r.once(this,e,t)},e.prototype.emit=function(e){r.emit(this,e,this)},e.prototype.hasEventListener=function(e){var t="on"+e;return!(!this[t]||!this[t].after)},e}();t.Evented=a,t.EventedMixin=function(e){return function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return i(t,e),t.prototype.on=function(e,t){return n.after(this,"on"+e,t,!0)},t.prototype.once=function(e,t){return r.once(this,e,t)},t.prototype.emit=function(e,t){r.emit(this,e,t)},t.prototype.hasEventListener=function(e){var t="on"+e;return!(!this[t]||!this[t].after)},t}(e)}}.apply(null,n))||(e.exports=r)},1809:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(1960),i(1945)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=new n(function(e){var t=i;return e.split("/").forEach(function(e){t&&(t=t[e])}),t});t.resolveIncludes=function(e){return r.resolveIncludes(e)}}.apply(null,n))||(e.exports=r)},1891:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var i=new Uint32Array(1),n=new Uint8Array(i.buffer);t.int32To4Bytes=function(e){return i[0]=0|e,[n[0],n[1],n[2],n[3]]}}.apply(null,n))||(e.exports=r)},1946:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(1962),i(1564),i(1573),i(1567)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(){this._initialized=!1}return e.prototype.dispose=function(){this._program&&(this._program.dispose(),this._program=null),this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)},e.prototype.render=function(e,t,i,n){e&&(this._initialized||this._initialize(e),e.setBlendFunctionSeparate(1,771,1,771),e.bindVAO(this._vertexArrayObject),e.bindProgram(this._program),t.setSamplingMode(i),e.bindTexture(t,0),this._program.setUniform1i("u_tex",0),this._program.setUniform1f("u_opacity",n),e.drawArrays(5,0,4),e.bindVAO())},e.prototype._initialize=function(e){if(this._initialized)return!0;var t=i.bitBlit.attributes,o=r.createProgram(e,i.bitBlit);if(!o)return!1;var s=new Int8Array(16);s[0]=-1,s[1]=-1,s[2]=0,s[3]=0,s[4]=1,s[5]=-1,s[6]=1,s[7]=0,s[8]=-1,s[9]=1,s[10]=0,s[11]=1,s[12]=1,s[13]=1,s[14]=1,s[15]=1;var l=new a(e,t,{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:4,normalized:!1,divisor:0},{name:"a_tex",count:2,type:5120,offset:2,stride:4,normalized:!1,divisor:0}]},{geometry:n.createVertex(e,35044,s)});return this._program=o,this._vertexArrayObject=l,this._initialized=!0},e}()}.apply(null,n))||(e.exports=r)},1949:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e){this._array=[],e<=0&&console.error("strideInBytes must be positive!"),this._stride=e}return Object.defineProperty(e.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"index",{get:function(){return 4*this._array.length/this._stride},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"itemSize",{get:function(){return this._stride},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sizeInBytes",{get:function(){return 4*this._array.length},enumerable:!0,configurable:!0}),e.prototype.reset=function(){this.array.length=0},e.prototype.toBuffer=function(){return new Uint32Array(this._array).buffer},e.i1616to32=function(e,t){return 65535&e|t<<16},e.i8888to32=function(e,t,i,n){return 255&e|(255&t)<<8|(255&i)<<16|n<<24},e.i8816to32=function(e,t,i){return 255&e|(255&t)<<8|i<<16},e}()}.apply(null,n))||(e.exports=r)},1960:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return{background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\n  gl_FragColor = u_color;\n}\n","background.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\nvoid main() {\n  vec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\n\nvarying mediump vec2 v_uv;\n\nvoid main() {\n  lowp vec4 color = texture2D(u_tex, v_uv);\n\n  // Note: output in pre-multiplied alpha for correct alpha compositing\n  gl_FragColor = color *  u_opacity;\n}\n","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nvarying mediump vec2 v_uv;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n}\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\n// according to 4 different sigma and stores the results into the\n// four channel of the target framebuffer.\n\n// It is intended to be called twice; the first time to perform an\n// horizontal blur, and a second time to perform a vertical blur.\n\n// This shader is used to turn the highlight mask into a highlight\n// map. The highlight map is an approximation of the signed distance\n// field of the mask.\n\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// Blur direction information. There are two possible\n// configurations that the host code can use.\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\n//    case u_direction[0] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[2] = 1/WIDTH is in texel units\n//    and is used to sample the right texel from the texture map.\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\n//    case u_direction[1] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[3] = 1/HEIGHT is in texel units\n//    and is used to sample the right texel from the texture map.\nuniform mediump vec4 u_direction;\n\n// Source to destination channel selection matrix.\nuniform mediump mat4 u_channelSelector;\n\n// The highlight map is obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\n// it is the horizontally blurred highlight map and blurring it one more time\n// vertically will complete the process.\nuniform sampler2D u_texture;\n\n// The gaussian kernel. Note that it lacks the normalization constant, because\n// we want to store it unnormalized in the highlight map (i.e. having a peak\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\n// data) capabilities of the GPU to compute four different gaussian kernels, one\n// for each sigma.\nmediump vec4 gauss(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\n}\n\nmediump vec4 selectChannel(mediump vec4 sample) {\n  return u_channelSelector * sample;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight.\nvoid accumGauss(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\n  // Computes the gaussian weights, one for each sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump vec4 w = gauss(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\nvoid main(void) {\n  // Initialize accumulated values and weights to zero.\n  mediump vec4 tot = vec4(0.0, 0.0, 0.0, 0.0);\n  mediump vec4 weight = vec4(0.0, 0.0, 0.0, 0.0);\n\n  // Accumulates enough samples. These will be taken\n  // horizontally or vertically depending on the value\n  // of u_direction.\n  accumGauss(-5.0, tot, weight);\n  accumGauss(-4.0, tot, weight);\n  accumGauss(-3.0, tot, weight);\n  accumGauss(-2.0, tot, weight);\n  accumGauss(-1.0, tot, weight);\n  accumGauss(0.0, tot, weight);\n  accumGauss(1.0, tot, weight);\n  accumGauss(2.0, tot, weight);\n  accumGauss(3.0, tot, weight);\n  accumGauss(4.0, tot, weight);\n  accumGauss(5.0, tot, weight);\n\n  // Compute blurred values.\n  mediump vec4 rgba = tot / weight;\n\n  // Return the values. Note that each channel will contain\n  // the result of a different blur operation, one for each\n  // of the four chosen sigma.\n  gl_FragColor = vec4(rgba);\n}\n","highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\n// and shades the fragments according to their estimated distance from the\n// edge of the highlighted feature.\n\n// A shade texture is used to turn distance values into colors; the shade\n// texture is basically a color gradient and is recomputed on the host\n// every time that the user alters the highlight options.\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// The highlight map. Each channel is a blurred\n// version of the alpha channel of the highlight mask.\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma = u_sigmas[0];\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma = u_sigmas[1];\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma = u_sigmas[2];\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma = u_sigmas[3];\n// As of today, only channel 3 is used for distance estimation.\n// But the availability of different amounts of blur leaves the\n// door open to multi-scale approaches.\nuniform sampler2D u_texture;\n\n// The highlight map was obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// A 1-D texture used to shade the highlight.\nuniform sampler2D u_shade;\n\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\nuniform mediump vec2 u_minMaxDistance;\n\n// Signed distance estimation.\nmediump float estimateDistance() {\n  // Use the largest sigma and the corresponding distance value stored in the\n  // last channel of the highlight map.\n  mediump float sigma = u_sigmas[3];\n  mediump float y = texture2D(u_texture, v_texcoord)[3];\n\n  // Estimates the distance by linearization and local inversion around\n  // the inflection point. The inflection point is in x = 0.\n  const mediump float y0 = 0.5;                           // Value of the convolution at the inflection point.\n  mediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\n  mediump float d = (y - y0) / m0;                        // Inversion of a local linearization.\n\n  // Return the estimated distance.\n  return d;\n}\n\n// Shading based on estimated distance.\nmediump vec4 shade(mediump float d) {\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\n  mediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\n\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\n  // banding artifacts.\n  // We don't really know if we need this or not.\n  mappedDistance = clamp(mappedDistance, 0.0, 1.0);\n\n  // Sample the 1-D shade texture on its center line (i.e. on t=0.5).\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\n\nvoid main(void) {\n  // Estimate the distance.\n  mediump float d = estimateDistance();\n\n  // Shade the distance.\n  gl_FragColor = shade(d);\n}\n","textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\n// and passes its texture coordinates unchanged to the interpolator.\n\n// Vertex position.\nattribute mediump vec2 a_position;\n\n// Texture coordinates.\nattribute mediump vec2 a_texcoord;\n\n// Texture coordinates to be interpolated.\nvarying mediump vec2 v_texcoord;\n\nvoid main(void) {\n  // Pass the position unchanged.\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texture coordinates unchanged.\n  v_texcoord = a_texcoord;\n}\n"},materials:{fill:{"fill.frag":"precision lowp float;\n\n#ifdef PATTERN\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\nvoid main()\n{\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_opacity * v_color * color;\n#else\n  gl_FragColor = v_opacity * v_color;\n#endif // PATTERN\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  //if (gl_FragColor.a < 1.0 / 255.0) {\n  //  discard;\n  //}\n  gl_FragColor = v_id;\n#endif // ID\n}\n","fill.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux1;\nattribute vec2 a_aux2;\n\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/fill/vvUniforms.glsl>\n#include <materials/fill/vvFunctions.glsl>\n\n#ifdef PATTERN\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nconst float SIGNED_BYTE_TO_UNSIGNED = 128.0;\n\nvoid main()\n{\n#ifdef VV_OPACITY\n  v_opacity = getVVOpacity(a_vv.y);\n#else\n  v_opacity = 1.0;\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.x, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n\n#ifdef PATTERN\n  vec2 aux2 = (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\n\n  // calculate the pattern matrix\n  mat3 patternMatrix = mat3(1.0, 0.0, 0.0,\n                            0.0, 1.0, 0.0,\n                            0.0, 0.0, 1.0);\n\n  patternMatrix[0][0] = 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\n  patternMatrix[1][1] = 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\n\n  vec2 symbolOffset = u_zoomFactor * (a_aux1.zw - vec2(SIGNED_BYTE_TO_UNSIGNED));\n\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\n  // tile coordinates to texture coordinates.\n  v_tileTextureCoord = (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\n  v_tlbr = vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\n#endif // PATTERN\n\n  float z = 2.0 * (1.0 - a_visible); // clip the vertex if the geometry isn't visible\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos, 1.);\n\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\n\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR)|| defined(VV_OPACITY)\nattribute vec4 a_vv;\n#endif // VV_COLOR || VV_OPACITY\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n"},icon:{"icon.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nconst float softEdgeRatio = 1.0; // use blur here if needed\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  float size = max(v_size.x, v_size.y);\n  float dist = d * size * softEdgeRatio;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (v_outlineWidth > 0.25) {\n    lowp vec4 outlinePixelColor = v_outlineColor;\n\n    // outlines can't be larger than the size of the symbol\n    float clampedOutlineSize = min(v_outlineWidth, size);\n\n    outlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\n\n    // finally combine the outline and the fill colors (outline draws on top of fill)\n    gl_FragColor = v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n   lowp vec4 texColor = texture2D(u_texture, v_tex);\n   gl_FragColor = v_transparency * texColor;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"precision mediump float;\n\n//const float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst vec2 SIGNED_BYTE_TO_UNSIGNED = vec2(128.0);\n\n// per quad (instance) attributes (20 bytes ==> equivalent of 5 bytes per vertex)\nattribute vec2 a_pos;\nattribute vec4 a_vertexOffsetAndTex;\nattribute vec4 a_id; // since we need to render the Id as a color we need to break it into RGBA components. so just like a color, the Id is normalized.\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\n\nattribute float a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n// the of the icon given in pixels\nvarying mediump vec2 v_size;\n\n// icon color. If is a picture-marker it is used to tint the texture color\nvarying lowp vec4 v_color;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/icon/vvUniforms.glsl>\n#include <materials/icon/vvFunctions.glsl>\n\nvoid main()\n{\n  vec2 a_offset = a_vertexOffsetAndTex.xy;\n  vec2 a_tex = a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED; // offset to change from signed to unsigned byte\n  vec2 a_size = a_sizeAndOutlineWidth.xy;\n\n  // default values (we need them for the variations to come)\n  float a_angle = 0.0;\n  float delta_z = 2.0 * (1.0 - a_visible);\n  float depth = 0.0;\n  v_transparency = 1.0;\n\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  // vv size override the original symbol's size\n  float h = getVVMinMaxSize(a_vv.x, a_size.y);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  float h = u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  float h = getVVStopsSize(a_vv.x, a_size.y);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  float h = getVVUnitValue(a_vv.x, a_size.y);\n#endif // VV_SIZE_UNIT_VALUE\n\n  // make sure to preserve the aspect ratio of the symbol\n  vec2 size = vec2(h * a_size.x / a_size.y, h);\n  vec3 offset = vec3(a_offset * size / a_size, 0.0);\n  v_size = size;\n#else\n  vec3 offset = vec3(a_offset, 0.0);\n  v_size = a_size;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef SDF\n  offset *= 2.0;\n#endif // SDF\n\n\n#ifdef VV_ROTATION\n  // If we have a rotation VV, we need to rotate our offset\n  offset = u_displayMat3 * getVVRotationMat3(a_vv.w) * offset;\n#else\n  offset = u_displayMat3 * offset;\n#endif // VV_ROTATION\n  vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + offset;\n\n  gl_Position = vec4(pos.xy, delta_z, 1.0);\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#else\n  v_transparency = 1.0;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n  // output the texture coordinates and the transparency\n  v_tex = a_tex / u_mosaicSize;\n\n#ifdef SDF\n  v_outlineColor = a_outlineColor;\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\n  v_outlineWidth = min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\n#endif // SDF\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  interpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\nattribute vec4 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n"},label:{"label.frag":"precision lowp float;\n\nuniform mediump sampler2D u_referenceTex;\nuniform mediump vec2 u_screenSize;\nuniform mediump float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nvarying mediump float v_fadeStep;\n#else\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_color;\n#endif // ID\n\nconst vec3 epsilon = vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\nvoid main()\n{\n  mediump vec2 refTextPos = gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n  mediump vec4 referenceFragment = texture2D(u_referenceTex, refTextPos);\n#ifdef ID\n  mediump float alpha = clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n  // fill the whole quad\n  gl_FragColor = vec4(alpha);\n#else\n  // read the fade alpha\n  lowp float fadeAlpha = referenceFragment.a;\n\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float sdfAlpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\n\n  gl_FragColor = fadeAlpha * sdfAlpha * v_color;\n#endif\n}\n","label.vert":"precision mediump float;\n\nattribute vec2 a_pos;                  // 2 * 2 (2 x signed 16)\nattribute vec4 a_color;                // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset;         // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texAndSize;          // 4 (4 x unsigned byte) texture coordinatesm and font size. w is for the halo size\nattribute vec4 a_refSymbolAndPlacementOffset; // 4 (4 x unsigned byte) the offset of the reference symbol of the feature (x,y) and the placement offset (z, w) all given in pixels\nattribute float a_vvSize;\n\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nattribute mediump vec2 a_visibilityRange; // 2 x unsigned byte;\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\n\n\nuniform float u_mapRotation;\nuniform float u_mapAligned;\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\n// the curent zoom\nuniform mediump float u_zoomLevel; // the current zoom level X 10\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nuniform mediump float u_fadeStep;\nvarying mediump float v_fadeStep;\n#else\nvarying mediump vec4 v_color;\n#endif // ID\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n// by 16 and then at the shader devide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\nconst float outlineScale = 1.0 / 5.0;\nconst float sdfFontSize = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\nconst float maxSdfDistance = 8.0;\n\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float PLACEMENT_PADDING = 8.0;\n\n#include <materials/icon/vvUniforms.glsl>\n#include <materials/icon/vvFunctions.glsl>\n\nvoid main()\n{\n  float refSymbolSize = a_refSymbolAndPlacementOffset.y;\n    \n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    // vv size override the original symbol's size\n    float h = getVVMinMaxSize(a_vvSize, refSymbolSize);\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n    float h = u_vvSizeScaleStopsValue;\n  #endif // VV_SIZE_SCALE_STOPS\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    float h = getVVStopsSize(a_vvSize, refSymbolSize);\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    float h = getVVUnitValue(a_vvSize, refSymbolSize);\n  #endif // VV_SIZE_UNIT_VALUE\n    // make sure to preserve the aspect ratio of the symbol\n    float halfSize = h / 2.0;\n#else\n    float halfSize = refSymbolSize / 2.0;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  // make sure to clip the vertices in case that given record is marked as invisible\n  float z = 2.0 * (1.0 - a_visible);\n  float glyphAngle = a_refSymbolAndPlacementOffset.x * 360.0 / 254.0;\n  float mapAngle = u_mapRotation * 360.0 / 254.0;\n  float diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\n  \n  // make sure range is inclusive\n  z += 2.0 * (1.0 - step(a_visibilityRange.x, u_zoomLevel));\n  z += 2.0 * (1.0 - step(u_zoomLevel, a_visibilityRange.y));\n  z += 2.0 * u_mapAligned * step(90.0, diffAngle); \n\n  // encoded as dir + 1.0\n  vec2 placementDir = a_refSymbolAndPlacementOffset.zw - 1.0; \n  \n  // we use the list significant bit of the position in order to store the indication\n  // whether the vertex is of a halow of a glyph\n  mediump float halo = mod(a_pos, 2.0).x;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n\n  float fontSize = a_texAndSize.z;\n  float fontScale = fontSize / sdfFontSize;\n\n  vec2 vertexOffset = offsetPrecision * a_vertexOffset;\n  vec2 placementOffset = placementDir * (halfSize + PLACEMENT_PADDING);\n  vec3 glyphOffset = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n\n  v_tex = a_texAndSize.xy / u_mosaicSize;\n  v_antialiasingWidth = 0.106 * sdfFontSize / fontSize / u_pixelRatio;\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = halo * outlineScale * a_texAndSize.w / fontScale / maxSdfDistance;\n\n#ifdef ID\n  v_fadeStep = u_fadeStep;\n#else\n  v_color = a_color;\n  // Enable this code to visualize hidden glyphs\n  // float a = 1.0;\n  // if (z != 0.0)  {\n  //   a = 0.645;\n  // }\n  // v_color = vec4(a_color.rgb, a);\n#endif // ID\n}\n"},line:{"constants.glsl":"const float thinLineHalfWidth = 1.0; // meaning that a 2 pixels line width is considered a thin line\nconst float thinLineWidthFactor = 1.1;\n","line.frag":"precision lowp float;\n\nuniform lowp float u_blur;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform mediump float u_zoomFactor;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5; // YF: assumed that the width will be set to 31\nconst float widthFactor = 2.0;\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n#include <materials/line/constants.glsl>\n\nvoid main()\n{\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  mediump float thinLineFactor = max(thinLineWidthFactor * step(v_lineHalfWidth, thinLineHalfWidth), 1.0);\n\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\n  lowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF)\n  mediump float lineHalfWidth = widthFactor * v_lineHalfWidth;\n  mediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n  mediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n  // the distance is a proportional to the line width\n  float dist = d * lineHalfWidth;\n\n  lowp vec4 fillPixelColor = v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n  gl_FragColor = fillPixelColor;\n#elif defined(PATTERN)\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  gl_FragColor = v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n  // output the fragment color\n  gl_FragColor = v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\n\nattribute float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\n// T: ScreenCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3\nuniform highp mat3 u_dvMat3;\n\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\n\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\nconst float scale = 1.0 / 31.0;\n#ifdef SDF\nconst float widthFactor = 2.0;\n#else\nconst float widthFactor = 1.0;\n#endif\n\n\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\n#endif // PATTERN\n\n// we need to accumulated distance only if it is a pattern or an SDF line\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/line/vvUniforms.glsl>\n#include <materials/line/vvFunctions.glsl>\n\n// include the thin line parameters (thinLineHalfWidth and thinLineWidthFactor)\n#include <materials/line/constants.glsl>\n\nvoid main()\n{\n// size VV block\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  mediump float lineHalfWidth = 0.5 * getVVMinMaxSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\n  mediump float lineHalfWidth = 0.5 * u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\n  mediump float lineHalfWidth = 0.5 * getVVStopsSize(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\n  mediump float lineHalfWidth = 0.5 * getVVUnitValue(a_vv.x, 2.0 * a_accumulatedDistanceAndHalfWidth.y * scale);\n#endif // VV_SIZE_UNIT_VALUE\n\n#else // no VV\n  mediump float lineHalfWidth = a_accumulatedDistanceAndHalfWidth.y * scale;\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n#ifdef VV_OPACITY\nv_transparency = getVVOpacity(a_vv.z);\n#else\nv_transparency = 1.0;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nv_color = getVVColor(a_vv.y, a_color);\n#else\nv_color = a_color;\n#endif // VV_COLOR\n\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative),\n  // or in case that the line is not visible\n  float z = 2.0 * (step(lineHalfWidth, 0.0) + (1.0 - a_visible));\n\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\n  // to the SVG renderer\n  lineHalfWidth = max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\n  mediump float thinLineFactor = max(thinLineWidthFactor * step(lineHalfWidth, thinLineHalfWidth), 1.0);\n\n  v_lineHalfWidth = lineHalfWidth;\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\n  mediump vec2 dist = thinLineFactor * widthFactor * lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n  vec3 offset = u_dvMat3 * vec3(dist, 0.0);\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\n\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#if defined(PATTERN) || defined(SDF)\n  v_accumulatedDistance = a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif // PATTERN || SDF\n\n#ifdef PATTERN\nv_tlbr = vec4(a_tlbr.x / u_mosaicSize.x, a_tlbr.y / u_mosaicSize.y, a_tlbr.z / u_mosaicSize.x, a_tlbr.w / u_mosaicSize.y);\nv_patternSize = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif // PATTERN\n\n#ifdef ID\nv_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  float f = (sizeValue - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  return clamp(mix(u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w, f), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY)\nattribute vec3 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform float u_vvSizeScaleStopsValue;\n#endif\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n"},text:{"text.frag":"precision lowp float;\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n  \n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float alpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"precision mediump float;\n\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\n\nattribute vec2 a_pos;           // 2 * 2 (2 x signed 16)\nattribute vec4 a_id;            // 4 (4 x unsigned byte)\nattribute vec4 a_color;         // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texFontSize; // 4 (4 x unsigned byte) texture coordinatesm and font size\n\nattribute lowp float  a_visible; // a one byte controlling the visibility of the vertex (a separate visibility buffer), values are 0 or 1 (visible)\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\n// T: TileCoords -> DisplayCoords\n// Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precission we multiply the values\n// by 16 and then at the shader devide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\nconst float outlineScale = 1.0 / 5.0;\nconst float sdfFontSize = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the geometry to 6 on the outside.\n// 6 is actually the maximum distance outside the glyph, therefore it is the limitation of the halo which is 1/4 of the geometry size.\nconst float maxSdfDistance = 8.0;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n// import the VV inputs and functions (they are #ifdefed, so if the proper #define is not set it will end-up being a no-op)\n#include <materials/text/vvUniforms.glsl>\n#include <materials/text/vvFunctions.glsl>\n\nvoid main()\n{\n  // make sure to clip the vertices in case that given record is marked as invisible\n  float z = 2.0 * (1.0 - a_visible);\n\n  // we use the list significant bit of the position in order to store the indication whethe the vertex is of a halow of a glyph\n  mediump float halo = mod(a_pos, 2.0).x;\n\n  float fontSize = a_texFontSize.z;\n  float scale = 1.0;\n\n#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  #ifdef VV_SIZE_MIN_MAX_VALUE\n    // vv size override the original symbol's size\n    vec2 size = vec2(getVVMinMaxSize(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_MIN_MAX_VALUE\n\n  #ifdef VV_SIZE_SCALE_STOPS\n    vec2 size = vec2(u_vvSizeScaleStopsValue);\n  #endif // VV_SIZE_SCALE_STOPS\n\n  #ifdef VV_SIZE_FIELD_STOPS\n    vec2 size = vec2(getVVStopsSize(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_FIELD_STOPS\n\n  #ifdef VV_SIZE_UNIT_VALUE\n    vec2 size = vec2(getVVUnitValue(a_vv.x, a_texFontSize.z));\n  #endif // VV_SIZE_UNIT_VALUE\n\n    scale = size.x / fontSize;\n    fontSize = size.x;\n\n#endif // defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n\n  float fontScale = fontSize / sdfFontSize;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec3 offset = vec3(offsetPrecision * a_vertexOffset * scale, 0.0);\n\n#ifdef VV_ROTATION\n  vec3 glyphOffset = u_displayMat3 * getVVRotationMat3(a_vv.w) * offset;\n#else\n  vec3 glyphOffset = u_displayMat3 * offset;\n#endif // VV_ROTATION\n\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n  gl_Position = vec4(v_pos.xy, z, 1.0);\n\n\n  v_tex = a_texFontSize.xy / u_mosaicSize;\n  v_antialiasingWidth = 0.105 * sdfFontSize / fontSize / u_pixelRatio;\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = halo * outlineScale * a_texFontSize.w / fontScale / maxSdfDistance;\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#else\n  v_transparency = 1.0;\n#endif // VV_OPACITY\n\n#ifdef VV_COLOR\n  // we don't want to override the halo color\n  v_color = halo * a_color + (1.0 - halo) * getVVColor(a_vv.y, a_color);\n#else\n  v_color = a_color;\n#endif // VV_COLOR\n\n#ifdef ID\n  v_id = a_id;\n#endif // ID\n}\n","vvFunctions.glsl":"bool isNan(float val) {\n  return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  return clamp(u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z), u_vvSizeMinMaxValue.z, u_vvSizeMinMaxValue.w);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback) {\n  if (isNan(colorValue)) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n","vvUniforms.glsl":"#if defined(VV_COLOR) || defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE) || defined(VV_OPACITY) || defined(VV_ROTATION)\nattribute vec4 a_vv;\n#endif // VV_COLOR || VV_SIZE_MIN_MAX_VALUE || VV_SIZE_SCALE_STOPS || VV_SIZE_FIELD_STOPS || VV_SIZE_UNIT_VALUE || VV_OPACITY || VV_ROTATION\n\n#ifdef VV_COLOR\nuniform float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n"}},raster:{"solid.frag":"precision mediump float;\n\nvoid main(void) {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n","texture.frag":"precision mediump float;\n\n// Texture coordinates.\nvarying vec2 v_texcoord;\n\n// Texture sampler.\nuniform sampler2D u_texture;\n\n// Opacity.\nuniform float u_opacity;\n\nvoid main(void) {\n  vec4 color = texture2D(u_texture, v_texcoord);\n  color.a *= u_opacity;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n","transform.vert":'precision mediump float;\n\n// Vertex position. Assumed normalized in the [-1, 1] range.\nattribute vec2 a_position;\n\n// Texture coordinates. Assumed normalized in the [-1, 1] range.\nattribute vec2 a_texcoord;\n\n// Transform matrix.\nuniform mat4 u_transform;\n\n// Scales applied to position and texture coordinates to get the\n// "unnormalized" value.\nuniform float u_positionScale;\nuniform float u_texcoordScale;\n\n// Output texture coordinates, for interpolation.\nvarying vec2 v_texcoord;\n\nvoid main(void) {\n  gl_Position = u_transform * vec4(a_position * u_positionScale, 0.0, 1.0);\n  v_texcoord = a_texcoord * u_texcoordScale;\n}\n'},stencil:{"stencil.frag":"void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","stencil.vert":"attribute vec2 a_pos;\n\nvoid main() {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\n\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  vec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\n  \n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}}.apply(null,n))||(e.exports=r)},1962:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(1809)],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.bitBlit={name:"bitBlit",shaders:{vertexShader:i.resolveIncludes("bitBlit/bitBlit.vert"),fragmentShader:i.resolveIncludes("bitBlit/bitBlit.frag")},attributes:{a_pos:0,a_tex:1}}}.apply(null,n))||(e.exports=r)},2015:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e,t,i,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===i&&(i=0),void 0===n&&(n=0),this.x=e,this.y=t,this.width=i,this.height=n}return Object.defineProperty(e.prototype,"isEmpty",{get:function(){return this.width<=0||this.height<=0},enumerable:!0,configurable:!0}),e}()}.apply(null,n))||(e.exports=r)},2078:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(21),i(19),i(549),i(7),i(182),i(141),i(138),i(515),i(2458),i(2459),i(2460),i(2461),i(2462),i(2080),i.dj.m(e)],void 0===(r=function(e,t,i,n,r,a,o,s,l,u,d,f,c,h,_,p,v){var m=new r(10),g=new Map;return function(){function t(e,t,i,n){this.devicePixelRatio=t,this.allowUpdates=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._tileIndex=null,this._updateQueue=new Map,this._ongoingRequests=new Map,this._vectorTileLayer=e,this._container=n}return t.prototype.destroy=function(){this.stop(),this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic.dispose(),this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic.dispose(),this._glyphMosaic=null)},Object.defineProperty(t.prototype,"initialized",{get:function(){return this._broadcastPromise&&this._broadcastPromise.isFulfilled()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"spriteMosaic",{get:function(){return this._spriteMosaic},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"glyphMosaic",{get:function(){return this._glyphMosaic},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"ongoingRequestCount",{get:function(){return this._ongoingRequests.size},enumerable:!0,configurable:!0}),t.prototype.start=function(){var t=this;this.stop();var i=this._vectorTileLayer.styleRepository,r=new h(i.sprite,this.devicePixelRatio),l=r.load().then(function(){t._spriteMosaic=new c(1024,1024,250),t._spriteMosaic.setSpriteSource(r),n("stable-symbol-rendering")&&t._spriteMosaic.preloadSpriteItems()}),u=new f(i.glyphs);this._glyphMosaic=new d(1024,1024,u);var _,p=this._fetchTileMap(this._vectorTileLayer.tileIndexUrl),m=s.open(o.getAbsMid("./WorkerTileHandler",e,v),{client:this}).then(function(e){t._connection=e}),g=a.create(function(e){_=e},function(e){l.isFulfilled()||l.cancel(),p.isFulfilled()||p.cancel(),m.isFulfilled()||m.cancel()});return a.all([l,m]).then(function(){var e=t._connection.broadcast("setLayers",i.styleJSON);e.push(p),a.all(e).then(function(){_()})}),this._broadcastPromise=g,this._broadcastPromise},t.prototype.stop=function(){this._broadcastPromise&&!this._broadcastPromise.isFulfilled()&&this._broadcastPromise.cancel(),this._updateQueue.forEach(function(e){return e.cancel()}),this._ongoingRequests.forEach(function(e){return e.cancel()}),this._connection&&(this._connection.close(),this._connection=null)},t.prototype.updateStyle=function(){this._updateQueue.forEach(function(e){return e.cancel()}),this._updateQueue.clear(),this._ongoingRequests.forEach(function(e){return e.cancel()}),this._ongoingRequests.clear();var e,t=this._vectorTileLayer.styleRepository,i=a.create(function(t){e=t});return a.all(this._connection.broadcast("updateStyle",t.styleJSON)).then(function(){return e()}),this._broadcastPromise=i,i},t.prototype.updateTile=function(e,t){var i=this;if(!this.allowUpdates)return a.resolve(null);if(!this._broadcastPromise.isFulfilled()||!this._connection)return a.reject(new Error("no connection"));var n=Math.round(u.degToByte(t.state.rotation));if(e.rotation===n)return a.resolve(null);var r,o=e.key;return this._updateQueue.has(o.id)&&((r=this._updateQueue.get(o.id)).cancel(),this._updateQueue.delete(o.id)),e.rotation=n,r=e.client.invoke("updateSymbols",{key:e.id,rotation:n}).then(function(t){return i._updateQueue.delete(o.id),e.updateSymbolData(t),t}).catch(function(e){"cancel"!==e.dojoType&&i._updateQueue.delete(o.id)}),this._updateQueue.set(e.id,r),r},t.prototype.updateTileData=function(e){for(var t,i=e.tileId,n=this._container.children,r=0;r<n.length;r++)if((t=n[r]).id===i){t.updateTileData(e.tileData);break}},t.prototype.getVectorTile=function(e,t,i,n){var r=this;void 0===n&&(n=0);var a=new l(e,t,i,0);return this.getRefKey(a).then(function(e){var t=new p(a,e,r._vectorTileLayer.tileInfo,r._vectorTileLayer.styleRepository,0);return e?r.getTileData(t.key,0).then(function(e){return t.setData(e.tileData,e.client),t}):(t.setData(null,null),t)})},t.prototype.getTileData=function(e,t){var i=this;return this._broadcastPromise.isFulfilled()&&this._connection?this.getRefKey(e).then(function(n){if(!n)return a.resolve(null);var r=Math.round(u.degToByte(t));return i._getTileData(i._connection,e,n,r).then(function(e){return e&&e.tileData?e:a.reject(null)})}):a.reject(new Error("no connection"))},t.prototype.getRefKey=function(e){return this._tileIndex?this._tileIndex.dataKey(e):a.resolve(e)},t.prototype.getSprites=function(e){return this._spriteMosaic.getSpriteItems(e)},t.prototype.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.tileID,e.font,e.codePoints)},t.prototype.getStyleRepository=function(){return this._vectorTileLayer.styleRepository},t.prototype.getTileIndex=function(){return this._tileIndex},t.prototype._getTileData=function(e,t,i,n){var r=this,o=this._ongoingRequests.get(t.id);if(o)return o;var s=this._vectorTileLayer.getTileUrl(i.level,i.row,i.col),l=this._connection.getAvailableClient();return o=l.invoke("getTile",{key:t.id,refKey:i.id,url:s,rotation:n,cacheTile:this.allowUpdates}).then(function(e){return r._ongoingRequests.delete(t.id),{tileData:e,client:l}}).catch(function(e){return r._ongoingRequests.delete(t.id),l.invoke("destructTileData",t.id),a.reject(e)}),this._ongoingRequests.set(t.id,o),o},t.prototype._fetchTileMap=function(e){var t=this;if(this._vectorTileLayer.capabilities.operations.supportsTileMap&&this._vectorTileLayer.tilemapCache)return this._tileIndex=new _(this._vectorTileLayer.tilemapCache),a.resolve();if(!e)return a.resolve();var n=m.get(e);if(void 0!==n)return this._tileIndex=n,a.resolve();if(g.has(e))return g.get(e).then(function(e){t._tileIndex=new _(e.data)});var r=i(e,{responseType:"json"});return r.then(function(i){t._tileIndex=new _(i.data),g.delete(e),m.put(e,t._tileIndex)}),g.set(e,r),r},t}()}.apply(null,n))||(e.exports=r)},2079:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2015)],void 0===(r=function(e,t,i){return function(){function e(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new i(0,0,e,t))}return Object.defineProperty(e.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._height},enumerable:!0,configurable:!0}),e.prototype.allocate=function(e,t){if(e>this._width||t>this._height)return new i;for(var n=null,r=-1,a=0;a<this._free.length;++a){var o=this._free[a];e<=o.width&&t<=o.height&&(null===n||o.y<=n.y&&o.x<=n.x)&&(n=o,r=a)}return null===n?new i:(this._free.splice(r,1),n.width<n.height?(n.width>e&&this._free.push(new i(n.x+e,n.y,n.width-e,t)),n.height>t&&this._free.push(new i(n.x,n.y+t,n.width,n.height-t))):(n.width>e&&this._free.push(new i(n.x+e,n.y,n.width-e,n.height)),n.height>t&&this._free.push(new i(n.x,n.y+t,e,n.height-t))),new i(n.x,n.y,e,t))},e.prototype.release=function(e){for(var t=0;t<this._free.length;++t){var i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)},e}()}.apply(null,n))||(e.exports=r)},2080:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(26),i(84),i(38),i(66),i(1616),i(138),i(2463),i(1564)],void 0===(r=function(e,t,i,n,r,a,o,s,l,u){var d=["fillVertexBuffer","fillDDVertexBuffer","fillIndexBuffer","outlineVertexBuffer","outlineDDVertexBuffer","outlineIndexBuffer","lineVertexBuffer","lineDDVertexBuffer","lineIndexBuffer","iconVertexBuffer","iconDDVertexBuffer","iconIndexBuffer","textVertexBuffer","textDDVertexBuffer","textIndexBuffer","circleVertexBuffer","circleIndexBuffer"];return function(e){function t(){for(var t,i=[],n=0;n<arguments.length;n++)i[n]=arguments[n];var a=e.call(this)||this;return a._renderBuckets=[],a._vectorTileData=null,a._symbolUpdateData=null,a.coords=[0,0],a.bounds=[0,0,0,0],a.tileTransform={transform:r.mat4f32.create(),displayCoord:r.vec2f32.create()},a.stencilData={mask:0,reference:0},i.length>0&&(t=a.acquire).call.apply(t,[a].concat(i)),a}return i(t,e),t.prototype.reset=function(){s.pool.release(this.key),this.key=null,this.refKey=null,this.coords[0]=0,this.coords[1]=0,this.bounds[0]=0,this.bounds[1]=0,this.bounds[2]=0,this.bounds[3]=0,this.width=0,this.height=0,this.resolution=null,this.rotation=0,this._vectorTileData=null,this.styleLayers=null,this.client=null,this.id=null,this.tileTransform.transform.fill(0),this.tileTransform.displayCoord.fill(0),this.stencilData.mask=0,this.stencilData.reference=0,this._renderBuckets.length=0,this._symbolUpdateData=null,this.stage=null},t.prototype.acquire=function(e,t,i,n,r){this.key=e,this.refKey=t;var o=i.lodAt(e.level),s=null!==o?o.resolution:0,l=i.size[0]*s,u=i.origin,d=e.col*l,f=e.row*l,c=i.spatialReference,h=0;if(c&&(c._isWrappable?c._isWrappable():c.isWrappable)){var _=a.getInfo(c);h=_.valid[1]-_.valid[0]}var p=e.world*h,v=u.x+d+p,m=u.y-f,g=v+l,y=m-l;this.coords[0]=v,this.coords[1]=m,this.bounds[0]=v,this.bounds[1]=m,this.bounds[2]=g,this.bounds[3]=y,this.widthInPixels=i.size[1],this.coordRange=4096,this.resolution=s,this.rotation=r,this.styleLayers=n,this.id=e.id},t.prototype.setData=function(e,t){this._vectorTileData=e,this.client=t},t.prototype.updateSymbolData=function(e){e&&(this._symbolUpdateData=e,this.requestRender())},t.prototype.updateTileData=function(e){this._vectorTileData=e,this.stage.requestRender()},t.prototype.dispose=function(){for(var e=["fillVertexArrayObject","fillDDVertexArrayObject","outlineVertexArrayObject","lineVertexArrayObject","lineDDVertexArrayObject","iconVertexArrayObject","iconDDVertexArrayObject","textVertexArrayObject","textDDVertexArrayObject","circleVertexArrayObject","fillVertexBuffer","fillDDVertexBuffer","fillIndexBuffer","outlineVertexBuffer","outlineDDVertexBuffer","outlineIndexBuffer","lineVertexBuffer","lineDDVertexBuffer","lineIndexBuffer","iconVertexBuffer","iconDDVertexBuffer","iconIndexBuffer","textVertexBuffer","textDDVertexBuffer","textIndexBuffer","circleVertexBuffer","circleIndexBuffer","texture"],t=0;t<e.length;++t){var i=e[t];this[i]&&(this[i].dispose(),this[i]=null)}this._renderBuckets.length=0},t.prototype.getCpuMemoryUsage=function(){return null!=this._vectorTileData&&this._vectorTileData.bufferData?this._vectorTileData.bufferData.reduce(function(e,t){return e+t.byteLength},0)+this._vectorTileData.bufferDataInfo.byteLength+this._vectorTileData.bucketDataInfo.byteLength:0},t.prototype.getGpuMemoryUsage=function(){var e=this,t=d.reduce(function(t,i){return e[i]?t+e[i].size:t},0);return this.texture&&(t+=this.texture.descriptor.width*this.texture.descriptor.height*4),t},t.prototype.attachWithContext=function(e){this.stage={context:e},this.attached=this.attach()},t.prototype._commitChanges=function(){this._vectorTileData&&(this.dispose(),this._createRenderBuckets(),this._createBufferObjects(),this._vectorTileData=null)},t.prototype._createRenderBuckets=function(){for(var e=new Uint32Array(this._vectorTileData.bucketDataInfo),t=e.length,i=0;i<t;){var n=e[i];switch(e[i+1]){case 0:var r=new l.BackgroundRenderBucket;r.layerID=n,this._renderBuckets.push(r),i+=2;break;case 1:var a=new l.FillRenderBucket;a.layerID=n,a.triangleElementStart=e[i+2],a.triangleElementCount=e[i+3],a.outlineElementStart=e[i+4],a.outlineElementCount=e[i+5],this._renderBuckets.push(a),i+=6;break;case 2:var o=new l.LineRenderBucket;o.layerID=n,o.triangleElementStart=e[i+2],o.triangleElementCount=e[i+3],this._renderBuckets.push(o),i+=4;break;case 3:var s=new l.SymbolRenderBucket;s.layerID=n,s.isSDF=0!==e[i+2];var u=i+3,d=e[u];if(u++,d>0)for(var f=void 0,c=void 0,h=void 0,_=0;_<d;_++)f=e[u],c=e[u+1],h=e[u+2],s.markerPerPageElementsMap.set(f,[c,h]),u+=3;var p=u,v=e[p];if(p++,v>0)for(f=void 0,c=void 0,h=void 0,_=0;_<v;_++)f=e[p],c=e[p+1],h=e[p+2],s.glyphPerPageElementsMap.set(f,[c,h]),p+=3;this._renderBuckets.push(s),i+=5+3*d+3*v;break;case 4:var m=new l.CircleRenderBucket;m.layerID=n,m.triangleElementStart=e[i+2],m.triangleElementCount=e[i+3],this._renderBuckets.push(m),i+=4;break;default:console.error("Bad bucket type!"),i+=2}}},t._createBufferToObject=function(){var e=[];return e[1]={create:u.createVertex,var:"fillVertexBuffer"},e[2]={create:u.createVertex,var:"fillDDVertexBuffer"},e[3]={create:u.createIndex,var:"fillIndexBuffer"},e[4]={create:u.createVertex,var:"outlineVertexBuffer"},e[5]={create:u.createVertex,var:"outlineDDVertexBuffer"},e[6]={create:u.createIndex,var:"outlineIndexBuffer"},e[7]={create:u.createVertex,var:"lineVertexBuffer"},e[8]={create:u.createVertex,var:"lineDDVertexBuffer"},e[9]={create:u.createIndex,var:"lineIndexBuffer"},e[10]={create:u.createVertex,var:"iconVertexBuffer"},e[11]={create:u.createVertex,var:"iconDDVertexBuffer"},e[12]={create:u.createIndex,var:"iconIndexBuffer"},e[13]={create:u.createVertex,var:"textVertexBuffer"},e[14]={create:u.createVertex,var:"textDDVertexBuffer"},e[15]={create:u.createIndex,var:"textIndexBuffer"},e[16]={create:u.createVertex,var:"circleVertexBuffer"},e[17]={create:u.createIndex,var:"circleIndexBuffer"},e},t.prototype._createBufferObjects=function(){for(var e=this.stage.context,i=new Uint32Array(this._vectorTileData.bufferDataInfo),n=i.length,r=0,a=0;a<n;a+=2,r++){var o=i[a];if(!(i[a+1]<=0||0===this._vectorTileData.bufferData[r].byteLength)){var s=t.bufferToObject[o];s?this[s.var]?this[s.var].setData(this._vectorTileData.bufferData[r]):this[s.var]=s.create(e,35044,this._vectorTileData.bufferData[r]):console.error("Bad buffer type "+o)}}},t.prototype.detach=function(){this.isReady&&this.client.invoke("destructTileData",this.id),this.dispose(),e.prototype.detach.call(this)},t.prototype.doRender=function(e){if(this.visible&&this.isReady){var t=this.stage.context,i=e.renderer;if(t&&i){this._commitChanges();var n=e.drawphase;this._symbolUpdateData&&(this._updateSymbolData(e,this._symbolUpdateData),this._symbolUpdateData=null),t.setStencilFunction(514,this.stencilData.reference,this.stencilData.mask);var r,a=this.styleLayers,o=void 0!==e.layerOpacity?e.layerOpacity:1;if(0!==o){var s=this._renderBuckets.length;if(0===n)for(var l=s-1;l>=0;l--){var u=this._renderBuckets[l];if(r=a.layers[u.layerID],!u||!r)return;1!==u.type&&0!==u.type||!u.hasData()||i.renderBucket(t,u,e.displayLevel,e.requiredLevel,n,this,r,o)}else for(l=0;l<s;l++){u=this._renderBuckets[l];if(r=a.layers[u.layerID],!u||!r)return;u.hasData()&&i.renderBucket(t,u,e.displayLevel,e.requiredLevel,n,this,r,o)}}}}},t.prototype._updateSymbolData=function(e,t){if(!t||!t.bucketDataInfo)return!0;var i=new Uint32Array(t.bucketDataInfo),n=i.length;if(0===n)return!0;if(!this.isReady)return this.requestRender(),!1;for(var r=this.stage.context,a=new Uint32Array(t.bufferDataInfo),o=a.length,s=0,d=0;d<o;d+=2,s++)switch(a[d]){case 10:this.iconVertexBuffer&&(this.iconVertexBuffer.dispose(),this.iconVertexBuffer=null),this.iconVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 11:this.iconDDVertexBuffer&&(this.iconDDVertexBuffer.dispose(),this.iconDDVertexBuffer=null),this.iconDDVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 12:this.iconIndexBuffer&&(this.iconIndexBuffer.dispose(),this.iconIndexBuffer=null),this.iconIndexBuffer=u.createIndex(r,35044,t.bufferData[s]);break;case 13:this.textVertexBuffer&&(this.textVertexBuffer.dispose(),this.textVertexBuffer=null),this.textVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 14:this.textDDVertexBuffer&&(this.textDDVertexBuffer.dispose(),this.textDDVertexBuffer=null),this.textDDVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 15:this.textIndexBuffer&&(this.textIndexBuffer.dispose(),this.textIndexBuffer=null),this.textIndexBuffer=u.createIndex(r,35044,t.bufferData[s])}for(var f=[],c=0;c<this._renderBuckets.length;c++)this._renderBuckets[c]instanceof l.SymbolRenderBucket||f.push(this._renderBuckets[c]);this._renderBuckets=f;for(var h,_=0;_<n;){var p=i[_];(h=new l.SymbolRenderBucket).layerID=p,h.isSDF=0!==i[_+2],this.styleLayers.layers.length>h.layerID&&this.styleLayers.layers[h.layerID].type===h.type&&f.push(h);var v=_+3,m=i[v];if(v++,m>0)for(var g=void 0,y=void 0,x=void 0,b=0;b<m;b++)g=i[v],y=i[v+1],x=i[v+2],h.markerPerPageElementsMap.set(g,[y,x]),v+=3;var V=v,w=i[V];if(V++,w>0)for(g=void 0,y=void 0,x=void 0,b=0;b<w;b++)g=i[V],y=i[V+1],x=i[V+2],h.glyphPerPageElementsMap.set(g,[y,x]),V+=3;_+=5+3*m+3*w}return this.iconVertexArrayObject&&(this.iconVertexArrayObject.dispose(),this.iconVertexArrayObject=null),this.iconDDVertexArrayObject&&(this.iconDDVertexArrayObject.dispose(),this.iconDDVertexArrayObject=null),this.textVertexArrayObject&&(this.textVertexArrayObject.dispose(),this.textVertexArrayObject=null),this.textDDVertexArrayObject&&(this.textDDVertexArrayObject.dispose(),this.textDDVertexArrayObject=null),!0},t.pool=new n(t),t.bufferToObject=t._createBufferToObject(),t}(o.DisplayObject)}.apply(null,n))||(e.exports=r)},2081:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(1946),i(515),i(2466),i(2467),i(2465),i(2468),i(2469),i(2470),i(2473),i(2474),i(1562)],void 0===(r=function(e,t,i,n,r,a,o,s,l,u,d,f,c,h){return function(){function e(){this._extrudeMatrix=i.mat4f32.create(),this._extrudeNoRotationMatrix=i.mat4f32.create(),this._extrudeRotateVector=i.vec3f32.fromValues(0,0,1),this._extrudeScaleVector=i.vec3f32.fromValues(1,1,1),this._backgroundColor=i.vec4f32.fromValues(1,0,0,1),this._state={rotation:0,size:[0,0]},this._cachedWidth=0,this._cachedHeight=0,this._cachedRotation=0,this._blitRenderer=new n,this._globalOpacityFBO=null,this._boundFBO=null,this._programCache=null}return e.prototype.initialize=function(e,t,i){void 0===i&&(i=!0),this._SpriteMosaic=e,this._glyphMosaic=t,this._ignoreSpeed=!i,this._fadeRecorder=new s.FadeRecorder(300)},e.prototype.dispose=function(){this._backgroundRenderer&&(this._backgroundRenderer.dispose(),this._backgroundRenderer=null),this._lineRenderer&&(this._lineRenderer.dispose(),this._lineRenderer=null),this._fillRenderer&&(this._fillRenderer.dispose(),this._fillRenderer=null),this._symbolRenderer&&(this._symbolRenderer.dispose(),this._symbolRenderer=null),this._circleRenderer&&(this._circleRenderer.dispose(),this._circleRenderer=null),this._tileInfoRenderer&&(this._tileInfoRenderer.dispose(),this._tileInfoRenderer=null),this._hittestFBO&&(this._hittestFBO.dispose(),this._hittestFBO=null),this._globalOpacityFBO&&(this._globalOpacityFBO.dispose(),this._globalOpacityFBO=null),this._blitRenderer&&(this._blitRenderer.dispose(),this._blitRenderer=null),this._boundFBO=null,this._programCache&&(this._programCache.dispose(),this._programCache=null),this._cachedWidth=0,this._cachedHeight=0,this._cachedRotation=0},e.prototype.initializeProgramCache=function(e){if(null===this._programCache){var t=new c.default;t.initialize(e),this._backgroundRenderer=new a(t),this._lineRenderer=new u(t),this._fillRenderer=new l(t),this._symbolRenderer=new d(t),this._circleRenderer=new o(t),this._tileInfoRenderer=new f(t),this._programCache=t}},e.prototype.setStateParams=function(e,t,n){this._fadeRecorder.recordLevel(n),this._state=e,this._state.size[0]===this._cachedWidth&&this._state.size[1]===this._cachedHeight&&this._state.rotation===this._cachedRotation||(this._extrudeScaleVector[0]=2/e.size[0],this._extrudeScaleVector[1]=-2/e.size[1],i.mat4.identity(this._extrudeMatrix),i.mat4.rotate(this._extrudeMatrix,this._extrudeMatrix,-e.rotation*r.C_DEG_TO_RAD,this._extrudeRotateVector),i.mat4.scale(this._extrudeMatrix,this._extrudeMatrix,this._extrudeScaleVector),i.mat4.transpose(this._extrudeMatrix,this._extrudeMatrix),i.mat4.identity(this._extrudeNoRotationMatrix),i.mat4.scale(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix,this._extrudeScaleVector),i.mat4.transpose(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix),this._cachedWidth=this._state.size[0],this._cachedHeight=this._state.size[1],this._cachedRotation=this._state.rotation)},e.prototype.drawClippingMasks=function(e,t){if(0!==t.length){e.setDepthWriteEnabled(!1),e.setDepthTestEnabled(!1),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setColorMask(!1,!1,!1,!1),e.setStencilOp(7680,7680,7681),e.setStencilWriteMask(255),e.setClearStencil(0);var i=e.gl;e.clear(i.STENCIL_BUFFER_BIT);for(var n=0,r=t;n<r.length;n++){var a=r[n];a.attached&&a.visible&&(e.setStencilFunctionSeparate(1032,519,a.stencilData.reference,a.stencilData.mask),this._backgroundRenderer.renderSolidColor(e,{u_matrix:a.tileTransform.transform,u_normalized_origin:a.tileTransform.displayCoord,u_coord_range:a.coordRange,u_depth:0,u_color:this._backgroundColor}))}e.setColorMask(!0,!0,!0,!0),e.setBlendingEnabled(!0)}},e.prototype.renderDebug=function(e,t){var i=t.key;this._backgroundColor.set([i.col%2,i.row%2,i.col%2==0&&i.row%2==0?1:0,.5]),this._backgroundRenderer.renderSolidColor(e,{u_matrix:t.tileTransform.transform,u_normalized_origin:t.tileTransform.displayCoord,u_coord_range:t.coordRange,u_depth:0,u_color:this._backgroundColor})},e.prototype.renderBucket=function(e,t,i,n,r,a,o,s){if(o&&!(void 0!==o.minzoom&&o.minzoom>i+1e-6||a.key.level===n&&void 0!==o.maxzoom&&o.maxzoom<=i-1e-6))switch(t.type){case 0:2!==r&&this._renderBackground(e,t,i,r,a,o,s);break;case 1:2!==r&&this._renderFill(e,t,i,r,a,o,s);break;case 2:1!==r&&3!==r||this._renderLine(e,t,i,r,a,o,s);break;case 3:2!==r&&3!==r||this._renderSymbol(e,t,i,r,n,a,o,s);break;case 4:2!==r&&3!==r||this._renderCircle(e,t,i,r,n,a,o,s)}},e.prototype.renderTileInfo=function(e,t){this._tileInfoRenderer.render(e,t)},e.prototype.setGlobalOpacity=function(e,t,i){if(1!==i){this._boundFBO=e.getBoundFramebufferObject();var n=t.pixelRatio,r=t.state.size,a=r[0],o=r[1],s=Math.round(a*n),l=Math.round(o*n);null!==this._globalOpacityFBO&&this._globalOpacityFBO.width===s&&this._globalOpacityFBO.height===l||(null!==this._globalOpacityFBO&&this._globalOpacityFBO.dispose(),this._globalOpacityFBO=h.create(e,{colorTarget:0,depthStencilTarget:3,width:s,height:l})),e.bindFramebuffer(this._globalOpacityFBO),e.setClearColor(0,0,0,0),e.clear(e.gl.COLOR_BUFFER_BIT)}},e.prototype.applyGlobalOpacity=function(e,t,i){if(1!==i){var n=t.pixelRatio,r=t.state.size,a=r[0],o=r[1],s=e.getViewport();e.setViewport(0,0,n*a,n*o),e.bindFramebuffer(this._boundFBO);var l=this._globalOpacityFBO.colorTexture;this._blitRenderer.render(e,l,9728,i),e.setViewport(s.x,s.y,s.width,s.height),this._boundFBO=null}},e.prototype.needsRedraw=function(){return this._fadeRecorder.needsRedraw()},e.prototype.hitTest=function(e,t,i,n,r,a,o){var s=[0,0],l=[0,0],u=e.state;u.toMap(s,[0,0]),u.toMap(l,[a,a]);var d=n.filter(function(e){return!(s[0]>e.bounds[2]||l[0]<e.bounds[0]||s[1]<e.bounds[3]||l[1]>e.bounds[1])});if(0===d.length)return[];d.sort(function(e,t){return e.key.level-t.key.level});for(var f=d.length,c=1;c<=f;c++){(y=d[c-1]).attached&&(y.stencilData.reference=c,y.stencilData.mask=255)}o(u,r,d);var _=e.context;this._hittestFBO||(this._hittestFBO=h.create(_,{colorTarget:0,depthStencilTarget:3,width:a,height:a}));var p=_.getViewport(),v=_.getBoundFramebufferObject();_.bindFramebuffer(this._hittestFBO),_.setViewport(0,0,a,a);var m=_.gl;_.setDepthWriteEnabled(!0),_.setStencilWriteMask(255),_.setClearColor(1,1,1,1),_.setClearDepth(1),_.setClearStencil(0),_.clear(m.COLOR_BUFFER_BIT|m.DEPTH_BUFFER_BIT|m.STENCIL_BUFFER_BIT),_.setDepthWriteEnabled(!1),this.drawClippingMasks(_,d),_.setBlendingEnabled(!1),_.setStencilWriteMask(0),_.setStencilOp(7680,7680,7681),_.setDepthFunction(515),_.setDepthTestEnabled(!0),_.setDepthWriteEnabled(!0),_.setStencilTestEnabled(!0);for(var g=0;g<f;g++){var y;(y=d[g]).attached&&y.doRender(e)}_.setStencilTestEnabled(!1),_.setDepthTestEnabled(!1),this._readbackBuffer||(this._readbackBuffer=new Uint8Array(4*a*a),this._readbackBuffer32=new Uint32Array(this._readbackBuffer.buffer)),this._hittestFBO.readPixels(0,0,a,a,6408,5121,this._readbackBuffer);var x=new Set,b=a*a,V=Math.round(b/2),w=this._readbackBuffer32[V];4294967295!==w&&x.add(w);for(c=0;c<b;c++)4294967295!==(w=this._readbackBuffer32[c])&&x.add(w);_.bindFramebuffer(v),_.setViewport(p.x,p.y,p.width,p.height);var S=[];return x.forEach(function(e){S.push(e)}),S},e.prototype._renderBackground=function(e,t,i,n,r,a,o){this._backgroundRenderer.render(e,t,i,n,r,a,this._SpriteMosaic,this._SpriteMosaic.pixelRatio,o)},e.prototype._renderLine=function(e,t,i,n,r,a,o){this._lineRenderer.render(e,t,i,n,this._state,r,a,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,o)},e.prototype._renderFill=function(e,t,i,n,r,a,o){this._fillRenderer.render(e,t,i,this._state.rotation,n,r,a,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,o)},e.prototype._renderCircle=function(e,t,i,n,r,a,o,s){var l=!0;r===a.key.level&&(l=!1),e.setStencilTestEnabled(l),this._circleRenderer.render(e,t,i,n,this._state.rotation,a,o,this._extrudeMatrix,s)},e.prototype._renderSymbol=function(e,t,i,n,r,a,o,s){var l=!0;r===a.key.level&&(l=!1),e.setStencilTestEnabled(l),this._symbolRenderer.render(e,t,i,n,this._state.rotation,this._fadeRecorder.getFadeValues(this._ignoreSpeed),a,o,this._SpriteMosaic,this._glyphMosaic,this._extrudeMatrix,this._extrudeNoRotationMatrix,this._SpriteMosaic.pixelRatio,s)},e}()}.apply(null,n))||(e.exports=r)},2458:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19),i(7),i(2015),i(2079),i(1560)],void 0===(r=function(e,t,i,n,r,a,o){var s;return function(){function e(e,t,n){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,!s&&i("stable-symbol-rendering")&&(s=new Set),this.width=e,this.height=t,this._glyphSource=n,this._binPack=new a(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}return e.prototype.getGlyphItems=function(e,t,o){for(var l=this,u=[],d=this._glyphSource,f=new Set,c=0,h=o;c<h.length;c++){var _=h[c],p=Math.floor(_*(1/256));f.add(p)}var v=[];return f.forEach(function(e){if(e<=256){var i=t+e;if(l._rangePromises.has(i))v.push(l._rangePromises.get(i));else{var n=d.getRange(t,e).then(function(){l._rangePromises.delete(i)},function(){l._rangePromises.delete(i)});l._rangePromises.set(i,n),v.push(n)}}}),n.all(v).then(function(e){var n,c=l._glyphIndex[t];if(c||(c={},l._glyphIndex[t]=c),i("stable-symbol-rendering")){s.clear();for(var h=0,_=o;h<_.length;h++){var p=_[h];s.add(p)}var v=[];f.forEach(function(e){v.push(e)}),v.sort(),n=[];for(var m=0,g=v;m<g.length;m++)for(var y=g[m],x=0;x<256;++x)n.push(256*y+x)}else n=o;for(var b=0,V=n;b<V.length;b++){var w=c[p=V[b]];if(w)i("stable-symbol-rendering")&&!s.has(p)||(u[p]={rect:w.rect,metrics:w.metrics,page:w.page});else{var S=d.getGlyph(t,p);if(S&&S.metrics){var D=S.metrics,T=void 0;if(0===D.width)T=new r(0,0,0,0);else{var I=D.width+6,A=D.height+6,E=I%4?4-I%4:4,z=A%4?4-A%4:4;1===E&&(E=5),1===z&&(z=5),(T=l._binPack.allocate(I+E,A+z)).isEmpty&&(l._dirties[l._currentPage]||(l._glyphData[l._currentPage]=null),l._currentPage=l._glyphData.length,l._glyphData.push(new Uint8Array(l.width*l.height)),l._dirties.push(!0),l._textures.push(void 0),l._binPack=new a(l.width-4,l.height-4),T=l._binPack.allocate(I+E,A+z));var O=l._glyphData[l._currentPage],C=S.bitmap,M=void 0,R=void 0;if(C)for(var P=0;P<A;P++){M=I*P,R=l.width*(T.y+P+1)+T.x;for(var F=0;F<I;F++)O[R+F+1]=C[M+F]}}c[p]={rect:T,metrics:D,tileIDs:null,page:l._currentPage},i("stable-symbol-rendering")&&!s.has(p)||(u[p]={rect:T,metrics:D,page:l._currentPage}),l._dirties[l._currentPage]=!0}}}return u})},e.prototype.removeGlyphs=function(e){for(var t in this._glyphIndex){var i=this._glyphIndex[t];if(i){var n=void 0;for(var r in i)if((n=i[r]).tileIDs.delete(e),0===n.tileIDs.size){for(var a=this._glyphData[n.page],o=n.rect,s=void 0,l=void 0,u=0;u<o.height;u++)for(s=this.width*(o.y+u)+o.x,l=0;l<o.width;l++)a[s+l]=0;delete i[r],this._dirties[n.page]=!0}}}},e.prototype.bind=function(e,t,i,n){void 0===n&&(n=0),this._textures[i]||(this._textures[i]=new o(e,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));var r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(this._glyphData[i]),e.bindTexture(r,n),this._dirties[i]=!1},e.prototype.dispose=function(){this._binPack=null;for(var e=0,t=this._textures;e<t.length;e++){var i=t[e];i&&i.dispose()}this._textures.length=0},e}()}.apply(null,n))||(e.exports=r)},2459:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(21),i(548),i(7)],void 0===(r=function(e,t,i,n,r){var a=function(){function e(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:for(var t=e.getMessage();t.next();)switch(t.tag()){case 3:for(var i=t.getMessage(),n=void 0,r=void 0,a=void 0,o=void 0,s=void 0,l=void 0,u=void 0;i.next();)switch(i.tag()){case 1:n=i.getUInt32();break;case 2:r=i.getBytes();break;case 3:a=i.getUInt32();break;case 4:o=i.getUInt32();break;case 5:s=i.getSInt32();break;case 6:l=i.getSInt32();break;case 7:u=i.getUInt32();break;default:i.skip()}n&&(this._metrics[n]={width:a,height:o,left:s,top:l,advance:u},this._bitmaps[n]=r);break;default:t.skip()}break;default:e.skip()}}return e.prototype.getMetrics=function(e){return this._metrics[e]},e.prototype.getBitmap=function(e){return this._bitmaps[e]},e}(),o=function(){function e(){this._ranges=[]}return e.prototype.getRange=function(e){return this._ranges[e]},e.prototype.addRange=function(e,t){this._ranges[e]=t},e}();return function(){function e(e){this._glyphInfo={},this._baseURL=e}return e.prototype.getRange=function(e,t){var o=this._getFontStack(e);if(o.getRange(t))return r.resolve();var s=256*t,l=s+255,u=this._baseURL.replace("{fontstack}",e).replace("{range}",s+"-"+l);return i(u,{responseType:"array-buffer"}).then(function(e){o.addRange(t,new a(new n(new Uint8Array(e.data),new DataView(e.data))))}).catch(function(){o.addRange(t,new a)})},e.prototype.getGlyph=function(e,t){var i=this._getFontStack(e);if(i){var n=Math.floor(t/256);if(!(n>256)){var r=i.getRange(n);if(r)return{metrics:r.getMetrics(t),bitmap:r.getBitmap(t)}}}},e.prototype._getFontStack=function(e){var t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new o),t},e}()}.apply(null,n))||(e.exports=r)},2460:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(515),i(2015),i(2079),i(1560)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e,t,i){void 0===i&&(i=0),this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,(e<=0||t<=0)&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new r(e-4,t-4)}return e.prototype.getWidth=function(e){return e>=this._size.length?-1:this._size[e][0]},e.prototype.getHeight=function(e){return e>=this._size.length?-1:this._size[e][1]},e.prototype.setSpriteSource=function(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new r(this._pageWidth-4,this._pageHeight-4);var t=Math.floor(this._pageWidth),i=Math.floor(this._pageHeight),n=new Uint32Array(t*i);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e},e.prototype.getSpriteItem=function(e,t){void 0===t&&(t=!1);var i=this._mosaicRects[e];if(i)return i;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;var n=this._sprites.getSpriteInfo(e);if(!n||!n.width||!n.height||n.width<0||n.height<0)return null;var r=n.width,a=n.height,o=this._allocateImage(r,a),s=o[0],l=o[1],u=o[2];return s.width<=0?null:(this._copy(s,n,l,u,t),i={rect:s,width:r,height:a,anchorX:0,anchorY:0,sdf:n.sdf,simplePattern:!1,pixelRatio:n.pixelRatio,page:l},this._mosaicRects[e]=i,i)},e.prototype.preloadSpriteItems=function(){for(var e=0,t=this._sprites.spriteNames;e<t.length;e++){var i=t[e];this.getSpriteItem(i,!0)}},e.prototype.getSpriteItems=function(e){for(var t={},i=0,n=e;i<n.length;i++){var r=n[i];t[r]=this.getSpriteItem(r)}return t},e.prototype.getMosaicItemPosition=function(e,t){var i=this.getSpriteItem(e,t),n=i&&i.rect;if(!n)return null;n.width=i.width,n.height=i.height;var r=i.width,a=i.height;return{size:[i.width,i.height],tl:[(n.x+2)/this._size[i.page][0],(n.y+2)/this._size[i.page][1]],br:[(n.x+2+r)/this._size[i.page][0],(n.y+2+a)/this._size[i.page][1]],page:i.page}},e.prototype.bind=function(e,t,i,n){void 0===i&&(i=0),void 0===n&&(n=0),this._textures[i]||(this._textures[i]=new a(e,{pixelFormat:6408,dataType:5121,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));var r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(r,n),this._dirties[i]=!1},e._copyBits=function(e,t,i,n,r,a,o,s,l,u,d){var f=n*t+i,c=s*a+o;if(d){c-=a;for(var h=-1;h<=u;f=((++h+u)%u+n)*t+i,c+=a)for(var _=-1;_<=l;_++)r[c+_]=e[f+(_+l)%l]}else for(h=0;h<u;h++){for(_=0;_<l;_++)r[c+_]=e[f+_];f+=t,c+=a}},e.prototype._copy=function(t,i,n,r,a,o){if(this._sprites&&"loaded"===this._sprites.loadStatus&&!(n>=this._mosaicsData.length)){var s=new Uint32Array(o?o.buffer:this._sprites.image.buffer),l=this._mosaicsData[n];l&&s||console.error("Source or target images are uninitialized!");var u=o?i.width:this._sprites.width;e._copyBits(s,u,i.x,i.y,l,r[0],t.x+2,t.y+2,i.width,i.height,a),this._dirties[n]=!0}},e.prototype._allocateImage=function(e,t){e+=2,t+=2;var a=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<a){var o=Math.pow(2,Math.ceil(i.log2(e))),s=Math.pow(2,Math.ceil(i.log2(t))),l=new n(0,0,e,t);return this._mosaicsData.push(new Uint32Array(o*s)),this._dirties.push(!0),this._size.push([o,s]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[o,s]]}var u=e%4?4-e%4:4,d=t%4?4-t%4:4;1===u&&(u=5),1===d&&(d=5);var f=this._binPack.allocate(e+u,t+d);return f.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new r(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[f,this._currentPage,[this._pageWidth,this._pageHeight]]},e.prototype.dispose=function(){this._binPack=null,this._mosaicRects={};for(var e=0,t=this._textures;e<t.length;e++){var i=t[e];i&&i.dispose()}this._textures.length=0},e}()}.apply(null,n))||(e.exports=r)},2461:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(26),i(0),i(21),i(7)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e,t){this.baseURL=e,this.devicePixelRatio=t,this._isRetina=!1,this._spritesData={},this.image=null,this.width=null,this.height=null,this.loadStatus="not-loaded"}return Object.defineProperty(e.prototype,"spriteNames",{get:function(){var e=[];for(var t in this._spritesData)e.push(t);return e.sort(),e},enumerable:!0,configurable:!0}),e.prototype.getSpriteInfo=function(e){return this._spritesData[e]},e.prototype.load=function(){var e=this;return this.loadStatus="loading",this.baseURL?this._loadSprites().then(function(){return e.loadStatus="loaded",e}).catch(function(t){return e.loadStatus="failed",e}):a.resolve(this)},e.prototype._loadSprites=function(){var e=this;this._isRetina=this.devicePixelRatio>1.15;var t=this.baseURL,i=this._isRetina?"@2x":"",n=""+t+i+".png";return a.all([r(t+i+".json",{responseType:"json"}),r(n,{responseType:"image"})]).then(function(t){var i=t[0],n=t[1],r=Object.keys(i.data);if(!r||0===r.length||1===r.length&&"_ssl"===r[0]||!n||!n.data)return e._spritesData=e.image=null,e.width=e.height=0,a.resolve(null);e._spritesData=i.data;var o=n.data;e.width=o.width,e.height=o.height;var s=document.createElement("canvas"),l=s.getContext("2d");s.width=o.width,s.height=o.height,l.drawImage(o,0,0,o.width,o.height);for(var u,d=l.getImageData(0,0,o.width,o.height),f=new Uint8Array(d.data),c=0;c<f.length;c+=4)u=f[c+3]/255,f[c]=f[c]*u,f[c+1]=f[c+1]*u,f[c+2]=f[c+2]*u;e.image=f})},e}()}.apply(null,n))||(e.exports=r)},2462:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(7),i(296),i(138)],void 0===(r=function(e,t,i,n,r){return function(){function e(e){if(e instanceof n)this._tilemapCache=e;else{if(!(e&&"index"in e))throw new Error("Invalid tilemap!");this._tilemap=e.index}}return e.prototype.dataKey=function(e){if(this._tilemapCache){var t=e.level,i=e.row,n=e.col,a=new r(e);return this._tilemapCache.fetchAvailabilityUpsample(t,i,n,a).then(function(){return a}).catch(function(e){if(e&&"cancel"===e.dojoType)throw e;return a.level=t,a.row=i,a.col=n,a})}return this._getIndexedDataKey(e)},e.prototype.forEach=function(e,t,i,n,r){this._callback=r,this._maxLevel=t+e,this._forEach(this._tilemap,t,i,n)},e.prototype._forEach=function(e,t,i,n){0!==e&&(this._callback(t,i,n),t!==this._maxLevel&&"object"==typeof e&&(this._forEach(e[0],t+1,2*i,2*n),this._forEach(e[1],t+1,2*i,2*n+1),this._forEach(e[2],t+1,2*i+1,2*n),this._forEach(e[3],t+1,2*i+1,2*n+1)))},e.prototype._getIndexedDataKey=function(e){var t=[e];if(e.level<0||e.row<0||e.col<0||e.row>>e.level>0||e.col>>e.level>0)return i.resolve(null);for(var n=e;0!==n.level;)n=new r(n.level-1,n.row>>1,n.col>>1,n.world),t.push(n);var a,o,s=this._tilemap,l=t.pop();if(1===s)return i.resolve(l);for(;t.length;)if(o=(1&(a=t.pop()).col)+((1&a.row)<<1),s){if(0===s[o]){l=null;break}if(1===s[o]){l=a;break}l=a,s=s[o]}return i.resolve(l)},e}()}.apply(null,n))||(e.exports=r)},2463:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(26),i(0)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(){return function(e){this.type=e}}();t.RenderBucket=r;var a=function(e){function t(){var t=e.call(this,2)||this;return t.triangleElementStart=0,t.triangleElementCount=0,t}return i(t,e),t.prototype.hasData=function(){return this.triangleElementCount>0},t}(r);t.LineRenderBucket=a;var o=function(e){function t(){var t=e.call(this,1)||this;return t.triangleElementStart=0,t.triangleElementCount=0,t.outlineElementStart=0,t.outlineElementCount=0,t}return i(t,e),t.prototype.hasData=function(){return this.triangleElementCount>0||this.outlineElementCount>0},t}(r);t.FillRenderBucket=o;var s=function(e){function t(){var t=e.call(this,3)||this;return t.markerPerPageElementsMap=new Map,t.glyphPerPageElementsMap=new Map,t.isSDF=!1,t}return i(t,e),t.prototype.hasData=function(){return this.markerPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0},t}(r);t.SymbolRenderBucket=s;var l=function(e){function t(){var t=e.call(this,4)||this;return t.triangleElementStart=0,t.triangleElementCount=0,t}return i(t,e),t.prototype.hasData=function(){return this.triangleElementCount>0},t}(r);t.CircleRenderBucket=l;var u=function(e){function t(){return e.call(this,0)||this}return i(t,e),t.prototype.hasData=function(){return!0},t}(r);t.BackgroundRenderBucket=u}.apply(null,n))||(e.exports=r)},2465:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(139)],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0});var n=function(){return function(e,t,i,n){this.fadeSpeed=e,this.minfadeLevel=t,this.maxfadeLevel=i,this.fadeChange=n}}();t.FadeProperties=n;var r=function(){function e(e){void 0===e&&(e=300),this._levelSnapshots=[],this._duration=e}return e.prototype.recordLevel=function(e){var t=i(),n=this._levelSnapshots;0===n.length&&(n.push({level:e,now:0}),n.push({level:e,now:0})),2!==n.length&&n[0].level===e||n.push({level:e,now:t})},e.prototype.needsRedraw=function(){if(0===this._levelSnapshots.length)return!1;for(var e=this._duration,t=this._levelSnapshots,i=t.length,n=t[i-1],r=-1;i>r+1&&t[r+1].now+e<n.now;)r++;for(r<0&&(r=0);r<i;r++)if(t[r].level!==n.level)return!0;return!1},e.prototype.getFadeValues=function(e){void 0===e&&(e=!1);for(var t=this._duration,n=i(),r=this._levelSnapshots;r.length>3&&r[1].now+t<n;)r.shift();r[1].now+t<n&&(r[0].level=r[1].level);var a=r[0].level,o=r[r.length-1],s=o.level,l=Math.min(a,s),u=Math.max(a,s),d=(o.level-r[1].level)/((o.now-r[1].now)/t),f=(n-o.now)/t*d;return e?{fadeSpeed:0,minfadeLevel:l,maxfadeLevel:u,fadeChange:0}:{fadeSpeed:d,minfadeLevel:l,maxfadeLevel:u,fadeChange:f}},e}();t.FadeRecorder=r}.apply(null,n))||(e.exports=r)},2466:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(1949),i(1891),i(1564),i(1567)],void 0===(r=function(e,t,i,n,r,a,o){return function(){function e(e){this._patternMatrix=i.mat3f32.create(),this._color=i.vec4f32.create(),this._solidrendererInitialized=!1,this._rendererInitialized=!1,this._programOptions={id:!1,pattern:!1},this._programCache=e,this._color.set([1,0,0,1])}return e.prototype.dispose=function(){this._solidVertexArrayObject&&(this._solidVertexArrayObject.dispose(),this._solidVertexArrayObject=null),this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)},e.prototype.renderSolidColor=function(e,t){this._solidrendererInitialized||this._initializeSolidRenderer(e),e.bindVAO(this._solidVertexArrayObject);var i=this._programOptions;i.id=!1,i.pattern=!1;var n=this._programCache.getProgram(0,0,i);e.bindProgram(n),n.setUniformMatrix4fv("u_transformMatrix",t.u_matrix),n.setUniform2fv("u_normalized_origin",t.u_normalized_origin),n.setUniform1f("u_coord_range",t.u_coord_range||4096),n.setUniform1f("u_depth",t.u_depth||0),n.setUniform4fv("u_color",t.u_color||this._color),e.drawArrays(5,0,4),e.bindVAO()},e.prototype.render=function(e,t,n,a,o,s,l,u,d){this._rendererInitialized||this._initialize(e);var f=s.getPaintValue("background-color",n),c=d*s.getPaintValue("background-opacity",n),h=s.getPaintValue("background-pattern",n),_=void 0!==h,p=f[3]*c,v=_||p<1;if((!v||0!==a)&&(v||1!==a)){var m=3===a,g=(m?1:0)<<1|(_?1:0),y=this._programOptions;y.id=m,y.pattern=_;var x=this._programCache.getProgram(0,g,y);if(e.bindVAO(this._vertexArrayObject),e.bindProgram(x),x.setUniform1f("u_coord_range",o.coordRange),x.setUniform1f("u_depth",s.z||0),x.setUniformMatrix4fv("u_transformMatrix",o.tileTransform.transform),x.setUniform2fv("u_normalized_origin",o.tileTransform.displayCoord),_){var b=l.getMosaicItemPosition(h,!0);if(!b)return;var V=512*Math.pow(2,Math.floor(n)-o.key.level)*u;i.mat3.identity(this._patternMatrix);var w=V/b.size[0],S=V/b.size[1];this._patternMatrix[0]=w,this._patternMatrix[4]=S,l.bind(e,9729,b.page,5),x.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),x.setUniform1f("u_opacity",c),x.setUniform2f("u_pattern_tl",b.tl[0],b.tl[1]),x.setUniform2f("u_pattern_br",b.br[0],b.br[1]),x.setUniform1i("u_texture",5)}else this._color[0]=p*f[0],this._color[1]=p*f[1],this._color[2]=p*f[2],this._color[3]=p,x.setUniform4fv("u_color",this._color);if(m){var D=r.int32To4Bytes(t.layerID);x.setUniform4f("u_id",D[0],D[1],D[2],D[3])}e.drawArrays(5,0,4),e.bindVAO()}},e.prototype._initializeSolidRenderer=function(e){if(this._solidrendererInitialized)return!0;var t=new Int8Array([0,0,1,0,0,1,1,1]),i=a.createVertex(e,35044,t),n=new o(e,this._programCache.getProgramAttributes(0),{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},{geometry:i});return this._solidVertexArrayObject=n,this._solidrendererInitialized=!0,!0},e.prototype._initialize=function(e){if(this._rendererInitialized)return!0;var t=[];t.push(n.i1616to32(0,0)),t.push(n.i1616to32(1,0)),t.push(n.i1616to32(0,1)),t.push(n.i1616to32(1,1));var i=new Uint32Array(t),r=a.createVertex(e,35044,i),s=new o(e,{a_pos:0},{geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},{geometry:r});return this._vertexArrayObject=s,this._rendererInitialized=!0,!0},e}()}.apply(null,n))||(e.exports=r)},2467:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(515),i(1891),i(1567)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e){this._viewProjMat=i.mat4f32.create(),this._offsetVector=i.vec3f32.create(),this._color=i.vec4f32.create(),this._strokeColor=i.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,a,o,s,l,u,d,f){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var c=u.hasDataDrivenRadius?1:u.getPaintValue("circle-radius",a),h=u.hasDataDrivenColor?[1,1,1,1]:u.getPaintValue("circle-color",a),_=u.hasDataDrivenOpacity?1:u.getPaintValue("circle-opacity",a),p=u.hasDataDrivenStrokeWidth?1:u.getPaintValue("circle-stroke-width",a),v=u.hasDataDrivenStrokeColor?[1,1,1,1]:u.getPaintValue("circle-stroke-color",a),m=u.hasDataDrivenStrokeOpacity?1:u.getPaintValue("circle-stroke-opacity",a),g=u.hasDataDrivenBlur?0:u.getPaintValue("circle-blur",a),y=_*h[3]*f;this._color[0]=y*h[0],this._color[1]=y*h[1],this._color[2]=y*h[2],this._color[3]=y,y=m*v[3]*f,this._strokeColor[0]=y*v[0],this._strokeColor[1]=y*v[1],this._strokeColor[2]=y*v[2],this._strokeColor[3]=y;var x=l.tileTransform.transform,b=u.getPaintValue("circle-translate",a);if(0!==b[0]||0!==b[1]){i.mat4.copy(this._viewProjMat,l.tileTransform.transform);var V=b[0],w=b[1],S=0,D=0,T=l.coordRange/512,I=(1<<l.key.level)/Math.pow(2,a)*T;if(1===u.getPaintValue("circle-translate-anchor",a)){var A=-n.C_DEG_TO_RAD*s,E=Math.sin(A),z=Math.cos(A);S=I*(V*z-w*E),D=I*(V*E+w*z)}else S=I*V,D=I*w;this._offsetVector[0]=S,this._offsetVector[1]=D,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),x=this._viewProjMat}var O=this._getCircleVAO(e,l);if(O){e.bindVAO(O);var C=3===o,M=C?1:0,R=this._programOptions;R.id=C;var P=this._programCache.getProgram(5,M,R);if(e.bindProgram(P),P.setUniformMatrix4fv("u_transformMatrix",x),P.setUniformMatrix4fv("u_extrudeMatrix",d),P.setUniform2fv("u_normalized_origin",l.tileTransform.displayCoord),P.setUniform1f("u_depth",u.z),P.setUniform1f("u_radius",c),P.setUniform4fv("u_color",this._color),P.setUniform1f("u_blur",g),P.setUniform1f("u_stroke_width",p),P.setUniform4fv("u_stroke_color",this._strokeColor),P.setUniform1f("u_antialiasingWidth",1.2),C){var F=r.int32To4Bytes(t.layerID);P.setUniform4f("u_id",F[0],F[1],F[2],F[3])}e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:16,normalized:!0,divisor:0},{name:"a_stroke_color",count:4,type:5121,offset:8,stride:16,normalized:!0,divisor:0},{name:"a_data",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getCircleVAO=function(e,t){if(t.circleVertexArrayObject)return t.circleVertexArrayObject;var i=t.circleVertexBuffer,n=t.circleIndexBuffer;return i&&n?(t.circleVertexArrayObject=new a(e,this._programCache.getProgramAttributes(5),this._vertexAttributes,{geometry:i},n),t.circleVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2468:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(515),i(1891),i(1567)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e){this._viewProjMat=i.mat4f32.create(),this._offsetVector=i.vec3f32.create(),this._patternMatrix=i.mat3f32.create(),this._color=i.vec4f32.create(),this._outlineColor=i.vec4f32.create(),this._initialized=!1,this._fillProgramOptions={id:!1,dd:!1,pattern:!1},this._outlineProgramOptions={id:!1,dd:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,a,o,s,l,u,d,f,c,h){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var _=void 0!==u.getPaintValue("fill-pattern",a),p=u.hasDataDrivenColor?[1,1,1,1]:u.getPaintValue("fill-color",a),v=u.hasDataDrivenOpacity?1:u.getPaintValue("fill-opacity",a),m=v*p[3]*h;this._color[0]=m*p[0],this._color[1]=m*p[1],this._color[2]=m*p[2],this._color[3]=m;var g,y=3===s;y&&(g=r.int32To4Bytes(t.layerID));var x=l.tileTransform.transform,b=l.coordRange/512,V=u.getPaintValue("fill-translate",a);if(0!==V[0]||0!==V[1]){i.mat4.copy(this._viewProjMat,l.tileTransform.transform);var w=V[0],S=V[1],D=0,T=0,I=(1<<l.key.level)/Math.pow(2,a)*b;if(1===u.getPaintValue("fill-translate-anchor",a)){var A=-n.C_DEG_TO_RAD*o,E=Math.sin(A),z=Math.cos(A);D=I*(w*z-S*E),T=I*(w*E+S*z)}else D=I*w,T=I*S;this._offsetVector[0]=D,this._offsetVector[1]=T,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),x=this._viewProjMat}if(this._drawFill(e,t,a,s,l,u,d,x,c,h,y,g),u.getPaintValue("fill-antialias",a)&&!_&&t.outlineElementCount>0&&(1===s||3===s)){var O=u.hasDataDrivenOutline;if(u.outlineUsesFillColor){if(1!==this._color[3])return;this._outlineColor[0]=this._color[0],this._outlineColor[1]=this._color[1],this._outlineColor[2]=this._color[2],this._outlineColor[3]=this._color[3]}else{var C=u.hasDataDrivenOutlineColor?[1,1,1,1]:u.getPaintValue("fill-outline-color",a),M=v*C[3]*h;this._outlineColor[0]=M*C[0],this._outlineColor[1]=M*C[1],this._outlineColor[2]=M*C[2],this._outlineColor[3]=M}var R=.75/c,P=this._getOutlineVAO(e,l,O);if(P){e.bindVAO(P);var F=(y?1:0)<<1|(O?1:0),U=this._outlineProgramOptions;U.id=y,U.dd=O;var L=this._programCache.getProgram(2,F,U);e.bindProgram(L),L.setUniformMatrix4fv("u_transformMatrix",x),L.setUniformMatrix4fv("u_extrudeMatrix",f),L.setUniform2fv("u_normalized_origin",l.tileTransform.displayCoord),L.setUniform1f("u_depth",u.z+1/65536),L.setUniform1f("u_outline_width",R),L.setUniform4fv("u_color",this._outlineColor),y&&L.setUniform4f("u_id",g[0],g[1],g[2],g[3]),e.drawElements(4,t.outlineElementCount,5125,12*t.outlineElementStart),e.bindVAO()}}}},e.prototype._initialize=function(e){return!!this._initialized||(this._fillVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},this._fillVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:8,normalized:!0,divisor:0}]},this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,normalized:!1,divisor:0}]},this._outlineVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:12,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:8,stride:12,normalized:!0,divisor:0}]},this._initialized=!0,!0)},e.prototype._drawFill=function(e,t,n,r,a,o,s,l,u,d,f,c){var h=o.getPaintValue("fill-pattern",n),_=void 0!==h,p=o.hasDataDrivenOpacity?1:d*o.getPaintValue("fill-opacity",n),v=o.hasDataDrivenColor?[1,1,1,1]:o.getPaintValue("fill-color",n),m=p*v[3]*d;this._color[0]=m*v[0],this._color[1]=m*v[1],this._color[2]=m*v[2],this._color[3]=m;var g=o.hasDataDrivenFill,y=_||m<1||g;if((!y||0!==r)&&(y||1!==r)){var x=this._getFillVAO(e,a,g);if(x){e.bindVAO(x);var b=(f?1:0)<<2|(g?1:0)<<1|(_?1:0),V=this._fillProgramOptions;V.id=f,V.dd=g,V.pattern=_;var w=this._programCache.getProgram(1,b,V);if(e.bindProgram(w),_){var S=s.getMosaicItemPosition(h,!0);if(!S)return e.bindVAO(),void e.bindProgram();var D=a.coordRange/512/Math.pow(2,Math.round(n)-a.key.level)/u;i.mat3.identity(this._patternMatrix);var T=1/(S.size[0]*D),I=1/(S.size[1]*D);this._patternMatrix[0]=T,this._patternMatrix[4]=I,s.bind(e,9729,S.page,5),w.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),w.setUniform2f("u_pattern_tl",S.tl[0],S.tl[1]),w.setUniform2f("u_pattern_br",S.br[0],S.br[1]),w.setUniform1i("u_texture",5)}w.setUniformMatrix4fv("u_transformMatrix",l),w.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),w.setUniform1f("u_depth",o.z+1/65536),w.setUniform4fv("u_color",this._color),f&&w.setUniform4f("u_id",c[0],c[1],c[2],c[3]),e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._getFillVAO=function(e,t,i){if(i){if(t.fillDDVertexArrayObject)return t.fillDDVertexArrayObject;var n=t.fillDDVertexBuffer,r=t.fillIndexBuffer;return n&&r?(t.fillDDVertexArrayObject=new a(e,this._programCache.getProgramAttributes(1),this._fillVertexAttributesDD,{geometry:n},r),t.fillDDVertexArrayObject):null}if(t.fillVertexArrayObject)return t.fillVertexArrayObject;n=t.fillVertexBuffer,r=t.fillIndexBuffer;return n&&r?(t.fillVertexArrayObject=new a(e,this._programCache.getProgramAttributes(1),this._fillVertexAttributes,{geometry:n},r),t.fillVertexArrayObject):null},e.prototype._getOutlineVAO=function(e,t,i){if(i){if(t.outlineDDVertexArrayObject)return t.outlineDDVertexArrayObject;var n=t.outlineDDVertexBuffer,r=t.outlineIndexBuffer;return n&&r?(t.outlineDDVertexArrayObject=new a(e,this._programCache.getProgramAttributes(2),this._outlineVertexAttributesDD,{geometry:n},r),t.outlineDDVertexArrayObject):null}if(t.outlineVertexArrayObject)return t.outlineVertexArrayObject;n=t.outlineVertexBuffer,r=t.outlineIndexBuffer;return n&&r?(t.outlineVertexArrayObject=new a(e,this._programCache.getProgramAttributes(2),this._outlineVertexAttributes,{geometry:n},r),t.outlineVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2469:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(515),i(1891),i(1567)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e){this._initialized=!1,this._viewProjMat=i.mat4f32.create(),this._offsetVector=i.vec3f32.create(),this._color=i.vec4f32.create(),this._dashArray=i.vec2f32.create(),this._programOptions={id:!1,dd:!1,pattern:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,a,o,s,l,u,d,f,c,h){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var _=l.tileTransform.transform,p=l.coordRange/512,v=u.getPaintValue("line-translate",a);if(0!==v[0]||0!==v[1]){i.mat4.copy(this._viewProjMat,l.tileTransform.transform);var m=v[0],g=v[1],y=0,x=0,b=(1<<l.key.level)/Math.pow(2,a)*p,V=s.rotation;if(1===u.getPaintValue("line-translate-anchor",a)){var w=-n.C_DEG_TO_RAD*V,S=Math.sin(w),D=Math.cos(w);y=b*(m*D-g*S),x=b*(m*S+g*D)}else y=b*m,x=b*g;this._offsetVector[0]=y,this._offsetVector[1]=x,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),_=this._viewProjMat}var T=u.getPaintValue("line-pattern",a),I=void 0!==T,A=1/c,E=u.getPaintValue("line-blur",a),z=u.hasDataDrivenColor?[1,1,1,1]:u.getPaintValue("line-color",a),O=u.hasDataDrivenOpacity?1:u.getPaintValue("line-opacity",a),C=u.hasDataDrivenWidth?1:u.getPaintValue("line-width",a),M=O*z[3]*h;this._color[0]=M*z[0],this._color[1]=M*z[1],this._color[2]=M*z[2],this._color[3]=M;var R,P=u.hasDataDrivenLine,F=3===o;F&&(R=r.int32To4Bytes(t.layerID));var U=this._getLineVAO(e,l,P);if(U){e.bindVAO(U);var L=(F?1:0)<<2|(P?1:0)<<1|(I?1:0),N=this._programOptions;N.id=F,N.dd=P,N.pattern=I;var B=this._programCache.getProgram(3,L,N);if(e.bindProgram(B),B.setUniformMatrix4fv("u_transformMatrix",_),B.setUniformMatrix4fv("u_extrudeMatrix",f),B.setUniform2fv("u_normalized_origin",l.tileTransform.displayCoord),B.setUniform1f("u_depth",u.z),B.setUniform1f("u_blur",E),B.setUniform1f("u_antialiasing",A),B.setUniform4fv("u_color",this._color),B.setUniform1f("u_width",C),F&&B.setUniform4f("u_id",R[0],R[1],R[2],R[3]),I){var k=d.getMosaicItemPosition(T,!0);k&&(d.bind(e,9729,k.page,5),B.setUniform2f("u_pattern_tl",k.tl[0],k.br[1]),B.setUniform2f("u_pattern_br",k.br[0],k.tl[1]),B.setUniform2f("u_spriteSize",p*k.size[0],k.size[1]),B.setUniform1i("u_texture",5))}else{var j=u.getPaintValue("line-dasharray",a);j.length<2&&(j=[1,-1]);var W=p;this._dashArray[0]=W*j[0],this._dashArray[1]=W*j[1],B.setUniform2fv("u_dasharray",this._dashArray)}e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5123,offset:8,stride:12,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:20,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:20,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5122,offset:8,stride:20,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:12,stride:20,normalized:!0,divisor:0},{name:"a_width",count:1,type:5126,offset:16,stride:20,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getLineVAO=function(e,t,i){if(i){if(t.lineDDVertexArrayObject)return t.lineDDVertexArrayObject;var n=t.lineDDVertexBuffer,r=t.lineIndexBuffer;return n&&r?(t.lineDDVertexArrayObject=new a(e,this._programCache.getProgramAttributes(3),this._vertexAttributesDD,{geometry:n},r),t.lineDDVertexArrayObject):null}if(t.lineVertexArrayObject)return t.lineVertexArrayObject;n=t.lineVertexBuffer,r=t.lineIndexBuffer;return n&&r?(t.lineVertexArrayObject=new a(e,this._programCache.getProgramAttributes(3),this._vertexAttributes,{geometry:n},r),t.lineVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2470:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2471),i(2472)],void 0===(r=function(e,t,i,n){return function(){function e(e){this._iconRenderer=new i(e),this._sdfRenderer=new n(e)}return e.prototype.dispose=function(){this._iconRenderer&&(this._iconRenderer.dispose(),this._iconRenderer=null),this._sdfRenderer&&(this._sdfRenderer.dispose(),this._sdfRenderer=null)},e.prototype.render=function(e,t,i,n,r,a,o,s,l,u,d,f,c,h){t.hasData()&&(t.markerPerPageElementsMap.size>0&&this._iconRenderer.render(e,t,i,n,r,a,o,s,l,d,f,h),t.glyphPerPageElementsMap.size>0&&this._sdfRenderer.render(e,t,i,n,r,a,o,s,u,d,f,c,h))},e}()}.apply(null,n))||(e.exports=r)},2471:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(515),i(1891),i(1567)],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e){this._viewProjMat=i.mat4f32.create(),this._offsetVector=i.vec3f32.create(),this._spritesTextureSize=i.vec2f32.create(),this._color=i.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1,dd:!1,sdf:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,a,o,s,l,u,d,f,c,h,_){var p=this;this._initialized||this._initialize(e);var v=d.hasDataDrivenIconSize?1:d.getLayoutValue("icon-size",a),m=d.hasDataDrivenIconColor?[1,1,1,1]:d.getPaintValue("icon-color",a),g=d.hasDataDrivenIconOpacity?1:d.getPaintValue("icon-opacity",a),y=m[3]*g*_;this._color[0]=y*m[0],this._color[1]=y*m[1],this._color[2]=y*m[2],this._color[3]=y;var x=d.getLayoutValue("icon-rotation-alignment",a);2===x&&(x=1===d.getLayoutValue("symbol-placement",a)?0:1);var b=0===x,V=t.isSDF,w=d.hasDataDrivenIcon,S=3===o,D=n.degToByte(s),T=u.tileTransform.transform,I=d.getPaintValue("icon-translate",a);if(0!==I[0]||0!==I[1]){i.mat4.copy(this._viewProjMat,u.tileTransform.transform);var A=I[0],E=I[1],z=0,O=0,C=u.coordRange/512,M=(1<<u.key.level)/Math.pow(2,a)*C;if(1===d.getPaintValue("icon-translate-anchor",a)){var R=-n.C_DEG_TO_RAD*s,P=Math.sin(R),F=Math.cos(R);z=M*(A*F-E*P),O=M*(A*P+E*F)}else z=M*A,O=M*E;this._offsetVector[0]=z,this._offsetVector[1]=O,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),T=this._viewProjMat}var U=b?c:h,L=this._getIconVAO(e,u,w);if(L){e.bindVAO(L);var N=(S?1:0)<<2|(w?1:0)<<1|(V?1:0),B=this._programOptions;B.id=S,B.dd=w,B.sdf=V;var k=this._programCache.getProgram(4,N,B);if(e.bindProgram(k),V){var j=d.getPaintValue("icon-halo-color",a),W=d.getPaintValue("icon-halo-width",a);k.setUniform4f("u_outlineColor",j[0],j[1],j[2],j[3]),k.setUniform1f("u_outlineSize",W)}if(k.setUniformMatrix4fv("u_transformMatrix",T),k.setUniformMatrix4fv("u_extrudeMatrix",U),k.setUniform2fv("u_normalized_origin",u.tileTransform.displayCoord),k.setUniform1f("u_depth",d.z),k.setUniform1f("u_mapRotation",D),k.setUniform1f("u_keepUpright",0),k.setUniform1f("u_level",10*a),k.setUniform1f("u_fadeSpeed",10*l.fadeSpeed),k.setUniform1f("u_minfadeLevel",10*l.minfadeLevel),k.setUniform1f("u_maxfadeLevel",10*l.maxfadeLevel),k.setUniform1f("u_fadeChange",10*(a+l.fadeChange)),k.setUniform1i("u_texture",5),k.setUniform1f("u_size",v),k.setUniform4fv("u_color",this._color),S){var H=r.int32To4Bytes(t.layerID);k.setUniform4f("u_id",H[0],H[1],H[2],H[3])}t.markerPerPageElementsMap.forEach(function(t,i){p._spritesTextureSize[0]=f.getWidth(i)/4,p._spritesTextureSize[1]=f.getHeight(i)/4,k.setUniform2fv("u_mosaicSize",p._spritesTextureSize),f.bind(e,9729,i,5),e.drawElements(4,t[1],5125,12*t[0])}),e.bindVAO()}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getIconVAO=function(e,t,i){if(i){if(t.iconDDVertexArrayObject)return t.iconDDVertexArrayObject;var n=t.iconDDVertexBuffer,r=t.iconIndexBuffer;return n&&r?(t.iconDDVertexArrayObject=new a(e,this._programCache.getProgramAttributes(4),this._vertexAttributesDD,{geometry:n},r),t.iconDDVertexArrayObject):null}if(t.iconVertexArrayObject)return t.iconVertexArrayObject;n=t.iconVertexBuffer,r=t.iconIndexBuffer;return n&&r?(t.iconVertexArrayObject=new a(e,this._programCache.getProgramAttributes(4),this._vertexAttributes,{geometry:n},r),t.iconVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2472:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(19),i(38),i(515),i(1891),i(1567)],void 0===(r=function(e,t,i,n,r,a,o){return function(){function e(e){this._viewProjMat=n.mat4f32.create(),this._offsetVector=n.vec3f32.create(),this._extrudeMat=n.mat4f32.create(),this._scaleVec=n.vec3f32.create(),this._haloColor=n.vec4f32.create(),this._sdfColor=n.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1,dd:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,o,s,l,u,d,f,c,h,_,p,v){var m=this;if(!i("esri-vector-tiles-avoid-text")){this._initialized||this._initialize(e);var g=r.degToByte(l),y=f.getLayoutValue("text-rotation-alignment",o);2===y&&(y=1===f.getLayoutValue("symbol-placement",o)?0:1);var x=0===y,b=f.getLayoutValue("text-keep-upright",o)&&x,V=3===s,w=.8*3/p,S=f.hasDataDrivenTextSize?1:f.getLayoutValue("text-size",o),D=f.hasDataDrivenTextColor?[1,1,1,1]:f.getPaintValue("text-color",o),T=f.hasDataDrivenTextOpacity?1:f.getPaintValue("text-opacity",o),I=D[3]*T*v;this._sdfColor[0]=I*D[0],this._sdfColor[1]=I*D[1],this._sdfColor[2]=I*D[2],this._sdfColor[3]=I,this._glyphTextureSize||(this._glyphTextureSize=n.vec2f32.fromValues(c.width/4,c.height/4));var A=d.tileTransform.transform,E=f.getPaintValue("text-translate",o);if(0!==E[0]||0!==E[1]){n.mat4.copy(this._viewProjMat,d.tileTransform.transform);var z=E[0],O=E[1],C=0,M=0,R=d.coordRange/512,P=(1<<d.key.level)/Math.pow(2,o)*R;if(1===f.getPaintValue("text-translate-anchor",o)){var F=-r.C_DEG_TO_RAD*l,U=Math.sin(F),L=Math.cos(F);C=P*(z*L-O*U),M=P*(z*U+O*L)}else C=P*z,M=P*O;this._offsetVector[0]=C,this._offsetVector[1]=M,this._offsetVector[2]=0,n.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),A=this._viewProjMat}x?n.mat4.copy(this._extrudeMat,h):n.mat4.copy(this._extrudeMat,_),this._scaleVec[0]=1/24,this._scaleVec[1]=1/24,this._scaleVec[2]=1,n.mat4.scale(this._extrudeMat,this._extrudeMat,this._scaleVec);var N=f.hasDataDrivenText,B=this._getSDFVAO(e,d,N);if(B){e.bindVAO(B);var k=(V?1:0)<<1|(N?1:0),j=this._programOptions;j.id=V,j.dd=N;var W=this._programCache.getProgram(6,k,j);if(e.bindProgram(W),W.setUniformMatrix4fv("u_transformMatrix",A),W.setUniformMatrix4fv("u_extrudeMatrix",this._extrudeMat),W.setUniform2fv("u_normalized_origin",d.tileTransform.displayCoord),W.setUniform1f("u_depth",f.z+1/65536),W.setUniform2fv("u_mosaicSize",this._glyphTextureSize),W.setUniform1f("u_mapRotation",g),W.setUniform1f("u_keepUpright",b?1:0),W.setUniform1f("u_level",10*o),W.setUniform1f("u_fadeSpeed",10*u.fadeSpeed),W.setUniform1f("u_minfadeLevel",10*u.minfadeLevel),W.setUniform1f("u_maxfadeLevel",10*u.maxfadeLevel),W.setUniform1f("u_fadeChange",10*(o+u.fadeChange)),W.setUniform1i("u_texture",6),W.setUniform1f("u_size",S),W.setUniform1f("u_antialiasingWidth",w),V){var H=a.int32To4Bytes(t.layerID);W.setUniform4f("u_id",H[0],H[1],H[2],H[3])}t.glyphPerPageElementsMap.forEach(function(t,i){m._renderGlyphRange(e,t,i,f,c,W,o,T*v,3)}),e.bindVAO()}}},e.prototype._renderGlyphRange=function(e,t,i,n,r,a,o,s,l){r.bind(e,9729,i,6);var u=n.getPaintValue("text-halo-color",o),d=n.getPaintValue("text-halo-width",o);if(u[3]>0&&d>0){var f=u[3]*s;this._haloColor[0]=f*u[0],this._haloColor[1]=f*u[1],this._haloColor[2]=f*u[2],this._haloColor[3]=f;var c=n.getPaintValue("text-halo-blur",o)*l,h=d*l;a.setUniform4fv("u_color",this._haloColor),a.setUniform1f("u_halo",1),a.setUniform1f("u_edgeDistance",h),a.setUniform1f("u_edgeBlur",c),e.drawElements(4,t[1],5125,12*t[0])}this._sdfColor[3]>0&&(a.setUniform4fv("u_color",this._sdfColor),a.setUniform1f("u_halo",0),a.setUniform1f("u_edgeDistance",0),a.setUniform1f("u_edgeBlur",0),e.drawElements(4,t[1],5125,12*t[0]))},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getSDFVAO=function(e,t,i){if(i){if(t.textDDVertexArrayObject)return t.textDDVertexArrayObject;var n=t.textDDVertexBuffer,r=t.textIndexBuffer;return n&&r?(t.textDDVertexArrayObject=new o(e,this._programCache.getProgramAttributes(6),this._vertexAttributesDD,{geometry:n},r),t.textDDVertexArrayObject):null}if(t.textVertexArrayObject)return t.textVertexArrayObject;n=t.textVertexBuffer,r=t.textIndexBuffer;return n&&r?(t.textVertexArrayObject=new o(e,this._programCache.getProgramAttributes(6),this._vertexAttributes,{geometry:n},r),t.textVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},2473:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(38),i(515),i(1564),i(1560),i(1567)],void 0===(r=function(e,t,i,n,r,a,o){return function(){function e(e){this._initialized=!1,this._color=i.vec4f32.fromValues(1,0,0,1),this._maxWidth=0,this._programOptions={id:!1,pattern:!1},this._programCache=e}return e.prototype.dispose=function(){this._outlineVertexArrayObject&&(this._outlineVertexArrayObject.dispose(),this._outlineVertexArrayObject=null),this._tileInfoVertexArrayObject&&(this._tileInfoVertexArrayObject.dispose(),this._tileInfoVertexArrayObject=null)},e.prototype.render=function(e,t){this._initialized||this._initialize(e);var i=this._programCache.getProgram(0,0,this._programOptions);if(i){e.bindVAO(this._outlineVertexArrayObject),e.bindProgram(i),i.setUniformMatrix4fv("u_transformMatrix",t.tileTransform.transform),i.setUniform2fv("u_normalized_origin",t.tileTransform.displayCoord),i.setUniform1f("u_coord_range",t.coordRange),i.setUniform1f("u_depth",0),i.setUniform4fv("u_color",this._color),e.setLineWidth(2),e.drawArrays(3,0,4),e.bindVAO();var n=this._getTexture(e,t);if(n){var r=this._programCache.getProgram(7,0,null);r&&(e.bindVAO(this._tileInfoVertexArrayObject),e.bindProgram(r),e.bindTexture(n,0),r.setUniformMatrix4fv("u_transformMatrix",t.tileTransform.transform),r.setUniform2fv("u_normalized_origin",t.tileTransform.displayCoord),r.setUniform1f("u_depth",0),r.setUniform1f("u_coord_ratio",t.coordRange/512),r.setUniform2f("u_delta",8,8),r.setUniform2f("u_dimensions",n.descriptor.width,n.descriptor.height),e.drawArrays(5,0,4),e.bindVAO())}}},e.prototype._initialize=function(e){if(this._initialized)return!0;var t={geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},i=new Int8Array([0,0,1,0,1,1,0,1]),n=r.createVertex(e,35044,i),a=new o(e,this._programCache.getProgramAttributes(0),t,{geometry:n}),s=new Int8Array([0,0,1,0,0,1,1,1]),l=r.createVertex(e,35044,s),u=new o(e,this._programCache.getProgramAttributes(7),t,{geometry:l});return this._outlineVertexArrayObject=a,this._tileInfoVertexArrayObject=u,this._initialized=!0,!0},e.prototype._getTexture=function(e,t){if(t.texture)return t.texture;this._canvas||(this._canvas=document.createElement("canvas"),this._canvas.setAttribute("id","canvas2d"),this._canvas.setAttribute("width","256"),this._canvas.setAttribute("height","32"),this._canvas.setAttribute("style","display:none"));var i=t.key.id,r=this._canvas.getContext("2d");r.font="24px sans-serif",r.textAlign="left",r.textBaseline="middle";var o=r.measureText(i),s=Math.pow(2,Math.ceil(n.log2(o.width+2)));return s>this._maxWidth&&(this._maxWidth=s),r.clearRect(0,0,this._maxWidth,32),r.fillStyle=t.key.level>t.refKey.level?"red":"blue",r.fillText(i,0,16),t.texture=new a(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728},this._canvas),t.texture},e}()}.apply(null,n))||(e.exports=r)},2474:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2475),i(1573)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(){this._cache=new Array(8);for(var e=0;e<8;e++)this._cache[e]={}}return e.prototype.dispose=function(){this._programRepo&&(this._programRepo.dispose(),this._programRepo=null)},e.prototype.getProgram=function(e,t,i){var n=this._cache[e];if(!n[t]){var r=this._programRepo.getProgram(this._getProgramTemplate(e),i);n[t]=r}return n[t]},e.prototype.getProgramAttributes=function(e){switch(e){case 0:return i.background.attributes;case 5:return i.circle.attributes;case 1:return i.fill.attributes;case 4:return i.icon.attributes;case 3:return i.line.attributes;case 2:return i.outline.attributes;case 6:return i.text.attributes;case 7:return i.tileInfo.attributes}},e.prototype.initialize=function(e){this._programRepo||(this._programRepo=new n.ProgramCache(e))},e.prototype._getProgramTemplate=function(e){switch(e){case 0:return i.background;case 5:return i.circle;case 1:return i.fill;case 4:return i.icon;case 3:return i.line;case 2:return i.outline;case 6:return i.text;case 7:return i.tileInfo}},e}();t.default=r}.apply(null,n))||(e.exports=r)},2475:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2476),i(1573)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){return n.glslifyDefineMap({ID:e.id,PATTERN:e.pattern})};t.background={name:"background",shaders:function(e){return{vertexShader:r(e)+i.resolveIncludes("background/background.vert"),fragmentShader:r(e)+i.resolveIncludes("background/background.frag")}},attributes:{a_pos:0}};var a=function(e){return n.glslifyDefineMap({ID:e.id})};t.circle={name:"circle",shaders:function(e){return{vertexShader:a(e)+i.resolveIncludes("circle/circle.vert"),fragmentShader:a(e)+i.resolveIncludes("circle/circle.frag")}},attributes:{a_pos:0,a_color:1,a_stroke_color:2,a_data:3}};var o=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,PATTERN:e.pattern})};t.fill={name:"fill",shaders:function(e){return{vertexShader:o(e)+i.resolveIncludes("fill/fill.vert"),fragmentShader:o(e)+i.resolveIncludes("fill/fill.frag")}},attributes:{a_pos:0,a_color:1}};var s=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd})};t.outline={name:"outline",shaders:function(e){return{vertexShader:s(e)+i.resolveIncludes("outline/outline.vert"),fragmentShader:s(e)+i.resolveIncludes("outline/outline.frag")}},attributes:{a_pos:0,a_offset:1,a_xnormal:2,a_color:3}};var l=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,SDF:e.sdf})};t.icon={name:"icon",shaders:function(e){return{vertexShader:l(e)+i.resolveIncludes("icon/icon.vert"),fragmentShader:l(e)+i.resolveIncludes("icon/icon.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}};var u=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,PATTERN:e.pattern})};t.line={name:"line",shaders:function(e){return{vertexShader:u(e)+i.resolveIncludes("line/line.vert"),fragmentShader:u(e)+i.resolveIncludes("line/line.frag")}},attributes:{a_pos:0,a_offsetAndNormal:1,a_accumulatedDistance:2,a_color:3,a_width:4}};var d=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd})};t.text={name:"text",shaders:function(e){return{vertexShader:d(e)+i.resolveIncludes("text/text.vert"),fragmentShader:d(e)+i.resolveIncludes("text/text.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}},t.tileInfo={name:"tileInfo",shaders:{vertexShader:i.resolveIncludes("tileInfo/tileInfo.vert"),fragmentShader:i.resolveIncludes("tileInfo/tileInfo.frag")},attributes:{a_pos:0}}}.apply(null,n))||(e.exports=r)},2476:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i(2477),i(1945)],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=new n(function(e){var t=i;return e.split("/").forEach(function(e){t&&(t=t[e])}),t});t.resolveIncludes=function(e){return r.resolveIncludes(e)}}.apply(null,n))||(e.exports=r)},2477:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return{background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform sampler2D u_texture;\n\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif // PATTERN\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main() {\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = u_opacity * color;\n#else\n  gl_FragColor = u_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","background.vert":"precision mediump float;\n\nattribute vec2 a_pos;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix; // can we use medium precision?\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\nvoid main() {\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\n\n#ifdef PATTERN\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif // PATTERN\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n}\n"},circle:{"circle.frag":"precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  mediump float dist = length(v_offset);\n\n  mediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\n\n  lowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\n\n  gl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","circle.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_color;\nattribute vec4 a_stroke_color;\nattribute vec4 a_data;\n\nconst float sizePrecision = 0.25; // 1/4\nconst float blurPrecision = 0.03125; // 1/32\n\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_radius;\nuniform lowp vec4 u_color;\nuniform mediump float u_blur;\nuniform mediump float u_stroke_width;\nuniform lowp vec4 u_stroke_color;\n\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\n\nvoid main()\n{\n  v_color = a_color * u_color;\n  v_stroke_color = a_stroke_color * u_stroke_color;\n  v_stroke_width = a_data[1] * sizePrecision * u_stroke_width;\n  v_radius = a_data[2] * u_radius;\n  v_blur = max(a_data[0] * blurPrecision + u_blur, u_antialiasingWidth / (v_radius + v_stroke_width));\n\n  mediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n  v_offset = offset;\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos * 0.5, 0.0, 1.0) + u_extrudeMatrix * (v_radius + v_stroke_width) * vec4(offset, 0.0, 0.0);\n}\n"},fill:{"fill.frag":"precision lowp float;\n\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\n\nvec4 mixColors(vec4 color1, vec4 color2) {\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n\n  return vec4(compositeColor, compositeAlpha);\n}\n\nvoid main()\n{\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_color[3] * color;\n#else\n  gl_FragColor = v_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","fill.vert":"precision mediump float;\n\nattribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform highp vec2 u_normalized_origin;\nuniform mediump float u_depth;\n\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nuniform lowp vec4 u_color;\nvarying lowp vec4 v_color;\n\nvoid main()\n{\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n#ifdef PATTERN\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\n  // (-4k to 8k -1) to texture coordinates.\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif // PATTERN\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\n}\n"},icon:{"icon.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture; // SDF texture\n#ifdef SDF\nuniform lowp vec4 u_color; // a color to override the one of the vertex\nuniform lowp vec4 u_outlineColor;\nuniform mediump float u_outlineSize;\n#endif // SDF\n\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\nvarying mediump vec2 v_size;\n\nvarying lowp vec4 v_color;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n\nvec4 mixColors(vec4 color1, vec4 color2) {\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n\n  return vec4(compositeColor, compositeAlpha);\n}\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  // 1 / 86 represents a single pixel given the size of the SDF is 128 and we add 4 pixels margins to deal with\n  // other non SDF types.\n  // The rasterized geometry takes only 86 pixels because of the extra 16 pixels margin for the outline.\n  const float sofetEdgeRatio = 0.248062016; // ==> (32.0 / 86.0) / 1.5;\n  float size = max(v_size.x, v_size.y);\n  float dist = d * sofetEdgeRatio * size;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (u_outlineSize > 0.25) {\n    lowp vec4 outlinePixelColor = u_outlineColor;\n    // the outline limit ratio is derived from the 16 pixels allocated for the outline and the fact that 1/86 represents\n    // a single pixel.\n    const float outlineLimitRatio = (16.0 / 86.0);\n    float clampedOutlineSize = sofetEdgeRatio * min(u_outlineSize, outlineLimitRatio * max(v_size.x, v_size.y));\n\n    outlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\n\n    // finally combine the outline and the fill colors\n    gl_FragColor = v_transparency * mixColors(fillPixelColor, outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n  lowp vec4 texColor = texture2D(u_texture, v_tex);\n  gl_FragColor = v_transparency * texColor;\n#endif // SDF\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_tex;\nattribute vec4 a_levelInfo;\n\n#ifdef DD\nattribute vec4 a_color;\nattribute mediump float a_size;\n#endif // DD\nuniform lowp vec4 u_color;\nuniform mediump float u_size;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the map's rotation from the north\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\n\n// indicate whether the current set of iconst should be kept upright when the map is rotated\nuniform lowp float u_keepUpright;\n\n// the rate of the change in the opacity (fade) of the icons\nuniform mediump float u_fadeSpeed;\n\n// the low level we transition (to/from)\nuniform mediump float u_minfadeLevel;\n\n// the high level we transition (to/from)\nuniform mediump float u_maxfadeLevel;\n\n// the amount of fade given teh current time past the last recorded level\nuniform mediump float u_fadeChange;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\nvarying mediump vec2 v_size;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\n// by 8 and then at the shader devide by the same number\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\n\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\n\nvoid main()\n{\n  mediump float a_labelMinLevel = a_levelInfo[0];\n  mediump float a_angle         = a_levelInfo[1];\n  mediump float a_minLevel      = a_levelInfo[2];\n  mediump float a_maxLevel      = a_levelInfo[3];\n\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\n  mediump float delta_z = 0.0;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z += (flip > 0) && (64 <= rotated) && (rotated < 192)\n\n  // u_level is the current service level adjusted for the change in font size\n  delta_z += 1.0 - step(a_minLevel, u_level); // Test if (level < minLevel)\n  delta_z += step(a_maxLevel, u_level); // Test if (maxLevel <= level)\n\n  // calculate the alpha given the change in the fade and the fade-speed\n  lowp float alpha = clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\n\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\n  v_transparency = (u_fadeSpeed >= 0.0 ? alpha : 1.0 - alpha);\n\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\n  if (u_maxfadeLevel < a_labelMinLevel)\n  {\n    v_transparency = 0.0;\n  }\n  if (u_minfadeLevel >= a_labelMinLevel)\n  {\n    v_transparency = 1.0;\n  }\n\n  // if label had been faded out, clip it\n  delta_z += step(v_transparency, 0.0);\n\n  vec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\n\n  v_size = abs(offset);\n\n#ifdef SDF\n  offset = (120.0 / 86.0) * offset;\n#endif // SDF\n\n#ifdef DD\n  mediump float icon_size = a_size * u_size;\n#else\n  mediump float icon_size = u_size;\n#endif // DD\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * icon_size * vec4(offset, delta_z, 0.0);\n\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_tex = a_tex.xy / u_mosaicSize;\n  v_transparency *= v_color.w;\n}\n"},line:{"line.frag":"varying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\n\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\n\nvarying mediump float v_blur;\n\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform mediump vec2 u_spriteSize;\nuniform sampler2D u_texture;\n\n// Horizontal scale is used to scale the horizontal texture coordinate v_normal.x before adding it as an offset to the\n// accumulated distance. Most vertices will have v_normal.x == 0, because the pattern must be sampled only depending on\n// the v_accumulatedDistance value. But tessellation at caps can have vertices with v_normal.x != 0, thus allowing to\n// \"keep moving\" for a few more pixel even when the line has ended or has not started yet.\nconst mediump float tileCoordRatio = 8.0;\n#else\nvarying mediump vec2 v_dasharray;\n#endif\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // We need to count for both sides of the line.\n  lowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n\n#ifdef PATTERN\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance aliong the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((v_accumulatedDistance + v_normal.x * v_lineHalfWidth * tileCoordRatio) / u_spriteSize.x, 1.0);\n\n  // in order to calculate the texture coordinates perpendicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value should be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolated normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolated normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / u_spriteSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  // finally write the fragment value\n  gl_FragColor = alpha * v_color[3] * color;\n#else\n  // now calculate the dashes given the accumulated distance of the line:\n  // start with calculating a normalized position along the line\n  lowp float dashPos =  mod(v_accumulatedDistance, v_dasharray.x + v_dasharray.y);\n\n  // calculate the contribution to the alpha of the dash part. It is provided by the shortest portion of the position along the dash.\n  // we must clamp since the value might be bigger than 1 or smaller than zero (when over a dash).\n  //   | <--- pos along the dash part\n  // -------_______-------_______\n  // when the dashPos is over the 'gap' part of the dash dasharray.x - dashPos is negative and therefore the alpha will\n  // get clamped to zero.\n  // when dasharray.x - dashPos is positive, or when dashPos is smaller than 1.0, it gives us a soft edge to each dash part.\n  // along the direction of the line.\n  lowp float dashAlpha = clamp(min(dashPos, v_dasharray.x - dashPos) + 0.5, 0.0, 1.0);\n\n  // if we don't have a no-data part to the dash then it is a solid line\n  dashAlpha = max(sign(-v_dasharray.y), dashAlpha);\n  // finally multiply the fragment's alpha by the calculated dash-alpha\n  alpha *= dashAlpha;\n\n  // output the fragment color\n  gl_FragColor = alpha * v_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"/* The implementation of the renderer is based on the article and implementation of MB described here:\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\n*/\n\nattribute vec2 a_pos;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistance;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\nuniform mediump float u_blur;\nuniform mediump float u_antialiasing; // the feather distance at which the line edge fades out\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\nvarying mediump vec2 v_normal;\n\n// the accumulated distance along the line. We need this information in order to render the dashes.\nvarying highp float v_accumulatedDistance;\n\nconst float scale = 1.0 / 31.0;\n\n#ifdef DD\nattribute vec4 a_color;\nattribute mediump float a_width;\n#endif // DD\nuniform lowp vec4 u_color;\nuniform mediump float u_width;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth; // the inset and outset of the line\nvarying mediump float v_blur;\n\n#ifndef PATTERN\nuniform mediump vec2 u_dasharray;\nvarying mediump vec2 v_dasharray;\n#endif\n\nvoid main()\n{\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#ifdef DD\n  v_lineHalfWidth = a_width * u_width;\n#else\n  v_lineHalfWidth = u_width;\n#endif // DD\n\n  v_lineHalfWidth += u_antialiasing;\n  v_lineHalfWidth *= 0.5;\n\n#ifndef PATTERN\n#ifdef DD\n  v_dasharray = u_dasharray * a_width;\n#else\n  v_dasharray = u_dasharray * u_width;\n#endif // DD\n#endif\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\n  mediump vec2 dist = v_lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n  // transform the vertex\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\n\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\n  v_accumulatedDistance = a_accumulatedDistance.x;\n\n  v_blur = u_blur + u_antialiasing;\n\n  #ifdef DD\n    v_color = a_color * u_color;\n  #else\n    v_color = u_color;\n  #endif // DD\n\n  #ifdef ID\n    v_id = u_id / 255.0;\n  #endif // ID\n}\n"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // Calculate the distance of the pixel from the line in pixels.\n  lowp float dist = abs(v_normal.y);\n\n  lowp float alpha = smoothstep(1.0, 0.0, dist);\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nuniform lowp vec4 u_color;\nvarying lowp vec4 v_color;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nuniform highp mat4 u_transformMatrix;\nuniform highp mat4 u_extrudeMatrix;\nuniform highp vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\n\nvarying lowp vec2 v_normal;\n\nconst float scale = 1.0 / 15.0;\n\nvoid main()\n{\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_normal = a_xnormal;\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\n  mediump vec4 dist = vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\n\n  // Remove the texture normal bit of the position before scaling it with the\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\n  // because we're extruding the line in pixel space, regardless of the current\n  // tile's zoom level.\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\n}\n"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nuniform mediump float u_edgeDistance;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\n// this is taken from http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n// and https://www.mapbox.com/blog/text-signed-distance-fields/\n// http://metalbyexample.com/rendering-text-in-metal-with-signed-distance-fields/\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  mediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_tex;\nattribute vec4 a_levelInfo;\n\nuniform lowp vec4 u_color; // always defined as halo does not support data driven but text does\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nvarying lowp vec4 v_color;\n\nuniform mediump float u_size;\n#ifdef DD\nattribute mediump float a_size;\n#endif // DD\nvarying mediump float v_size;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n\n// attribute bool a_visible; // --\x3e a one bit controlling the visibility of the vertex\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the map's rotation from the north\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\n\n// indicate whether the current set of iconst should be kept upright when the map is rotated\nuniform lowp float u_keepUpright;\n\n// the rate of the change in the opacity (fade) of the icons\nuniform mediump float u_fadeSpeed;\n\n// the low level we transition (to/from)\nuniform mediump float u_minfadeLevel;\n\n// the high level we transition (to/from)\nuniform mediump float u_maxfadeLevel;\n\n// the amount of fade given teh current time past the last recorded level\nuniform mediump float u_fadeChange;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying lowp vec2 v_tex;\n\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\n// by 8 and then at the shader divide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\n\n// outline position and appearance\nconst mediump float edgePos = 0.75; // defined by the SDF encoding\nuniform mediump float u_edgeDistance;\nuniform mediump float u_edgeBlur;\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\n\nvarying mediump float v_edgeDistance; // will factor in the size\nvarying mediump float v_edgeWidth; // will factor in the size\n\nuniform lowp float u_halo; // needed to avoid using the color attribute for halo\n\nvoid main()\n{\n  mediump float a_labelMinLevel = a_levelInfo[0];\n  mediump float a_angle        = a_levelInfo[1];\n  mediump float a_minLevel    = a_levelInfo[2];\n  mediump float a_maxLevel    = a_levelInfo[3];\n\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\n  mediump float delta_z = 0.0;\n\n  // TODO: force clipping the vertex in case that the vertex isn't visible\n  //delta_z += a_visible ? 0.0 : 1.0;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z += (flip > 0) && (64 <= rotated) && (rotated < 192)\n\n  // u_level is the current service level adjusted for the change in font size\n  delta_z += 1.0 - step(a_minLevel, u_level); // Test if (level < minLevel)\n  delta_z += step(a_maxLevel, u_level); // Test if (maxLevel <= level)\n\n  // calculate the alpha given the change in the fade and the fade-speed\n  lowp float alpha = clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\n\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\n  v_transparency = (u_fadeSpeed >= 0.0 ? alpha : 1.0 - alpha);\n\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\n  if (u_maxfadeLevel < a_labelMinLevel)\n  {\n    v_transparency = 0.0;\n  }\n  if (u_minfadeLevel >= a_labelMinLevel)\n  {\n    v_transparency = 1.0;\n  }\n\n  // if label has been faded out, clip it\n  delta_z += step(v_transparency, 0.0);\n\n  v_tex = a_tex.xy / u_mosaicSize;\n\n#ifdef DD\n  if (u_halo > 0.5)\n  {\n    v_color = u_color;\n  }\n  else\n  {\n    v_color = a_color * u_color;\n    // opacity already factored in a_color\n  }\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef DD\n  v_size = a_size * u_size;\n#else\n  v_size = u_size;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_edgeDistance = edgePos - u_edgeDistance / v_size;\n  v_edgeWidth = (u_antialiasingWidth + u_edgeBlur) / v_size;\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * v_size * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offests = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}}.apply(null,n))||(e.exports=r)}}]);